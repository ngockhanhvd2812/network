<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mô Hình Hóa IP và Subnet Mask</title>
    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --light-bg: #f8f9fa;
            --dark-bg: #343a40;
            --text-color-light: #333;
            --text-color-dark: #f8f9fa;
            --border-color: #dee2e6;
            --card-bg: white;
            --card-shadow: 0 4px 8px rgba(0,0,0,0.1);
            --font-family: Arial, sans-serif;
            --sidebar-width: 280px;
        }

        html[data-theme='dark'] {
            --primary-color: #4dabf7; /* Lighter blue for dark mode contrast */
            --primary-hover: #74c0fc;
            --light-bg: #212529;
            --dark-bg: #f8f9fa;
            --text-color-light: #f8f9fa;
            --text-color-dark: #343a40;
            --border-color: #495057;
            --card-bg: #343a40;
            --card-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        html {
            scroll-behavior: smooth;
            scroll-padding-top: 60px; /* Account for fixed header */
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            background-color: var(--light-bg);
            color: var(--text-color-light);
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        .main-content {
            padding: 20px 40px;
            padding-left: calc(var(--sidebar-width) + 40px);
        }

        h1, h2, h3 {
            color: var(--primary-color);
        }

        h3 {
             border-bottom: 2px solid var(--border-color);
             padding-bottom: 8px;
             margin-top: 30px;
        }

        .section {
            margin-bottom: 40px;
            padding: 25px;
            background-color: var(--card-bg);
            border-radius: 10px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        .section.done {
            border-left: 5px solid var(--success-color);
        }

        .interactive {
            border: 1px solid var(--primary-color);
            padding: 20px;
            border-radius: 10px;
            background-color: color-mix(in srgb, var(--primary-color) 10%, transparent);
            margin-top: 20px;
        }
        
        .case-study {
            padding: 15px;
            background-color: color-mix(in srgb, var(--info-color) 15%, transparent);
            border-left: 4px solid var(--info-color);
            margin-top: 25px;
            border-radius: 8px;
        }

        canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 100%;
            height: auto;
        }

        input, button, select, textarea {
            padding: 12px;
            margin: 10px 5px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text-color-light);
            width: calc(100% - 24px);
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
            font-family: monospace;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 30%, transparent);
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            width: auto;
        }

        button:hover {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        th, td {
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: color-mix(in srgb, var(--primary-color) 10%, transparent);
            font-weight: bold;
        }

        .result-box {
            margin-top: 20px;
            padding: 15px;
            background-color: color-mix(in srgb, var(--success-color) 10%, transparent);
            border-radius: 6px;
            color: var(--text-color-light);
            font-size: 16px;
            min-height: 50px;
            border-left: 4px solid var(--success-color);
            word-wrap: break-word;
        }
        #dhcpResult p[style*="text-align:right"] { 
            text-align: right; 
            color: var(--secondary-color);
            font-style: italic;
        }

        .bit-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        .bit {
            width: 25px; height: 25px; line-height: 25px;
            text-align: center; border: 1px solid var(--text-color-light);
            margin: 2px; font-size: 14px; font-weight: bold;
            color: white; transition: transform 0.3s;
        }

        .bit:hover { transform: scale(1.2); }
        .network-bit { background-color: var(--primary-color); }
        .host-bit { background-color: var(--success-color); }

        .analogy {
            background-color: color-mix(in srgb, var(--warning-color) 20%, transparent);
            padding: 15px; border-radius: 8px;
            margin: 20px 0; font-style: italic;
            border-left: 4px solid var(--warning-color);
        }
        
        .sidebar {
            position: fixed; top: 0; left: 0; width: var(--sidebar-width);
            height: 100vh; background-color: var(--card-bg);
            box-shadow: 2px 0 5px rgba(0,0,0,0.1); padding: 20px;
            overflow-y: auto; border-right: 1px solid var(--border-color); z-index: 1000;
        }
        .sidebar h2 { margin-top: 0; }
        .sidebar ul { list-style: none; padding: 0; margin: 0; }
        .sidebar li a {
            display: block; padding: 10px 15px; color: var(--text-color-light);
            text-decoration: none; border-radius: 5px; margin-bottom: 5px; transition: background-color 0.2s;
        }
        .sidebar li a:hover { background-color: color-mix(in srgb, var(--primary-color) 10%, transparent); }
        .sidebar li a.active { background-color: var(--primary-color); color: white; font-weight: bold; }
        .sidebar li a.done::before { content: '✔ '; color: var(--success-color); }

        .progress-container {
            width: 100%;
            background-color: var(--border-color);
            position: fixed; top: 0; left: 0; 
            z-index: 998; /* Below sidebar, above content */
        }
        .progress-bar {
            height: 8px; width: 0%; background-color: var(--primary-color); transition: width 0.1s linear;
        }

        .theme-toggle {
            position: absolute; top: 20px; right: 20px; background: none;
            border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px;
            cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center;
        }

        .modal {
            display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: var(--card-bg); margin: auto; padding: 30px;
            border: 1px solid var(--border-color); width: 80%; max-width: 600px;
            border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); position: relative;
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .close-button {
            color: var(--secondary-color); position: absolute; top: 10px; right: 20px;
            font-size: 28px; font-weight: bold; cursor: pointer;
        }
        .close-button:hover { color: var(--danger-color); }

        .strength-bar {
            height: 8px; background-color: var(--border-color);
            border-radius: 4px; margin-top: 8px; overflow: hidden;
        }
        .strength-bar div {
            height: 100%; width: 0; border-radius: 4px;
            transition: width 0.3s, background-color 0.3s;
        }
        #scoreHistoryChart {
            margin-top: 20px; padding: 15px;
            background-color: color-mix(in srgb, var(--secondary-color) 10%, transparent);
            border-radius: 8px;
        }
        #scoreHistoryChart svg { width: 100%; height: 100px; }
        #scoreHistoryChart .bar { fill: var(--primary-color); transition: height 0.3s; }
        #scoreHistoryChart .bar:hover { fill: var(--primary-hover); }

        .sidebar-toggle {
            display: none; /* Only show on mobile */
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1001; /* Above progress bar, below sidebar */
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            width: 45px; height: 45px;
            font-size: 24px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        .sidebar.show {
            transform: translateX(0);
        }
        
        @media (max-width: 992px) {
            body { padding-left: 0; }
            .main-content { padding: 20px; padding-left: 20px; padding-top: 70px; }
            .sidebar { transform: translateX(calc(-1 * var(--sidebar-width))); transition: transform 0.3s ease-in-out; }
            .sidebar-toggle { display: block; }
            .progress-container { width: 100%; left: 0; }
        }
    </style>
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>
    
    <button class="sidebar-toggle" id="sidebarToggle" aria-label="Open navigation">☰</button>
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <nav class="sidebar" id="sidebar">
        <h2>Bài Học</h2>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">🌙</button>
        <ul>
            <li><a href="#intro" id="nav-intro">Giới thiệu chung</a></li>
            <li><a href="#step1" id="nav-step1">Bước 1: IP Address là gì?</a></li>
            <li><a href="#step2" id="nav-step2">Bước 2: Subnet Mask là gì?</a></li>
            <li><a href="#step3" id="nav-step3">Bước 3: Tính toán Subnet</a></li>
            <li><a href="#step4" id="nav-step4">Bước 4: Quiz cơ bản</a></li>
            <li><a href="#step5" id="nav-step5">Bước 5: Mô phỏng mạng</a></li>
            <li><a href="#step6" id="nav-step6">Bước 6: Subnetting nâng cao</a></li>
            <li><a href="#step7" id="nav-step7">Bước 7: IP Public & Private</a></li>
            <li><a href="#step8" id="nav-step8">Bước 8: Quiz nâng cao</a></li>
            <li><a href="#step9" id="nav-step9">Bước 9: VLSM</a></li>
            <li><a href="#step10" id="nav-step10">Bước 10: IPv6</a></li>
            <li><a href="#step11" id="nav-step11">Bước 11: NAT</a></li>
            <li><a href="#step12" id="nav-step12">Bước 12: DHCP</a></li>
            <li><a href="#step13" id="nav-step13">Bước 13: DNS</a></li>
            <li><a href="#step14" id="nav-step14">Bước 14: Routing</a></li>
            <li><a href="#step15" id="nav-step15">Bước 15: Firewall</a></li>
            <li><a href="#step16" id="nav-step16">Bước 16: VPN</a></li>
            <li><a href="#step17" id="nav-step17">Bước 17: Wi-Fi</a></li>
            <li><a href="#step18" id="nav-step18">Bước 18: Quiz cuối cùng</a></li>
            <li><a href="#step19" id="nav-step19">Bước 19: Port & Socket</a></li>
            <li><a href="#step20" id="nav-step20">Bước 20: TCP vs UDP</a></li>
            <li><a href="#step21" id="nav-step21">Bước 21: Mô hình OSI</a></li>
            <li><a href="#step22" id="nav-step22">Bước 22: Quiz tổng hợp</a></li>
            <li><a href="#further-reading" id="nav-further-reading">Đọc thêm</a></li>
        </ul>
    </nav>
    
    <div class="main-content">
        <div class="section" id="preface">
            <h2>Lời nói đầu: Tại sao phải hiểu về Mạng Máy Tính?</h2>
            <p>Trong thế giới số hiện nay, từ việc lướt web, gửi email, chơi game online đến vận hành các trung tâm dữ liệu khổng lồ của Google, Amazon, tất cả đều dựa trên nền tảng mạng máy tính. Hiểu về địa chỉ IP, Subnet Mask và các khái niệm liên quan không chỉ là kiến thức dành cho chuyên gia IT mà còn là kỹ năng cần thiết cho bất kỳ ai muốn tìm hiểu sâu hơn về công nghệ.</p>
            <p>Khóa học này sẽ dẫn dắt bạn qua <strong>22 bước</strong>, từ những khái niệm cơ bản nhất như IP là gì cho đến các chủ đề nâng cao như VLSM, IPv6, routing, và bảo mật mạng. Hãy cùng bắt đầu hành trình khám phá xương sống của Internet!</p>
        </div>
        
        <h1>Mô Hình Hóa IP và Subnet Mask</h1>
        
        <div class="section" id="intro">
            <h2>Giới Thiệu Chung: IP, MAC, và DNS - Bộ Ba Quyền Lực</h2>
            <p>Trước khi đi sâu, hãy phân biệt rõ ba khái niệm cốt lõi:</p>
            <ul>
                <li><strong>Địa chỉ IP (Logical Address):</strong> Như địa chỉ nhà của bạn, có thể thay đổi nếu bạn chuyển nhà. Nó dùng để định tuyến gói tin trên Internet.</li>
                <li><strong>Địa chỉ MAC (Physical Address):</strong> Như số Căn cước công dân của thiết bị, là duy nhất và không đổi. Nó dùng để gửi dữ liệu trong mạng nội bộ (LAN).</li>
                <li><strong>DNS (Domain Name System):</strong> Như danh bạ điện thoại, dịch tên miền (ví dụ: google.com) thành địa chỉ IP để máy tính có thể hiểu và kết nối.</li>
            </ul>
            <p><strong>Ví dụ thực tế:</strong> Khi bạn gõ `google.com` vào trình duyệt, máy tính của bạn hỏi DNS server để lấy IP của Google. Sau đó, nó tạo gói tin với IP đích đó và gửi đến router. Quá trình này được điều phối bởi Giao thức phân giải địa chỉ (ARP). <strong>Khi một máy tính muốn gửi dữ liệu đến một IP trong cùng mạng LAN, nó sẽ gửi một gói tin ARP hỏi 'Ai có IP này? Hãy cho tôi biết địa chỉ MAC của bạn'. Máy tính có IP đó sẽ trả lời bằng địa chỉ MAC của mình.</strong> Tìm hiểu thêm tại <a href="https://tools.ietf.org/html/rfc826" target="_blank" rel="noopener noreferrer">RFC826 (ARP)</a>.</p>
        </div>

        <div class="section" id="step1">
            <h2>Bước 1: IP Address Là Gì? (Giống Như Địa Chỉ Nhà)</h2>
            <p>Hãy tưởng tượng internet như một thành phố khổng lồ. Mỗi máy tính, điện thoại là một ngôi nhà. Để gửi thư (dữ liệu), cần địa chỉ nhà chính xác. Đó là IP!</p>
            <p>IP IPv4 giống như: <strong>Số nhà. Đường. Phường. Quận</strong> - Nhưng dùng số: xxx.xxx.xxx.xxx (mỗi xxx từ 0-255). Ví dụ: 192.168.1.1.</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> IP 192.168.1.1 giống như "Số 1, Ngõ 1, Phố 168, Quận 192". Phần đầu là khu vực lớn, phần sau là nhà cụ thể.</div>
            
            <h3>Phân Lớp Địa Chỉ IPv4 (Khái niệm cũ nhưng hữu ích)</h3>
            <p>Trước đây, IPv4 được chia thành các lớp để xác định kích thước mạng mặc định. Mặc dù ngày nay CIDR (sẽ học ở bước 2) đã thay thế, hiểu về các lớp vẫn có ích.</p>
            <table>
                <thead><tr><th>Lớp</th><th>Dải địa chỉ đầu</th><th>Subnet Mask Mặc định</th><th>Mục đích sử dụng</th></tr></thead>
                <tbody>
                    <tr><td>A</td><td>1.0.0.0 – 126.255.255.255</td><td>255.0.0.0 (/8)</td><td>Các mạng rất lớn, ISP</td></tr>
                    <tr><td>B</td><td>128.0.0.0 – 191.255.255.255</td><td>255.255.0.0 (/16)</td><td>Các mạng trung bình đến lớn</td></tr>
                    <tr><td>C</td><td>192.0.0.0 – 223.255.255.255</td><td>255.255.255.0 (/24)</td><td>Các mạng nhỏ, mạng gia đình, doanh nghiệp nhỏ</td></tr>
                    <tr><td>D</td><td>224.0.0.0 – 239.255.255.255</td><td>N/A</td><td>Multicast (gửi đến một nhóm)</td></tr>
                    <tr><td>E</td><td>240.0.0.0 – 255.255.255.255</td><td>N/A</td><td>Dự trữ, nghiên cứu (Experimental)</td></tr>
                </tbody>
            </table>
            <p><strong>Lưu ý:</strong> Dải 127.x.x.x được dành riêng cho loopback (ví dụ `127.0.0.1` là chính máy tính của bạn).</p>

            <h3>Sơ Đồ Minh Họa: Cấu Trúc IP Như Một Ngôi Nhà</h3>
            <canvas id="ipHouseCanvas" width="600" height="300"></canvas>
            <div class="interactive">
                <h3>Tương Tác 1: Thử Nhập IP Và Xem Nó Sang Số Nhị Phân (0 và 1)</h3>
                <p>Máy tính hiểu IP bằng 32 con số 0 hoặc 1 (bit). Hãy thử nhập IP để xem!</p>
                <input type="text" id="ipInputBinary" placeholder="Nhập IP: 192.168.1.1" aria-label="IP to Binary Input" />
                <button onclick="convertToBinary()" aria-label="Convert IP to Binary">Chuyển Sang Nhị Phân</button>
                <div id="binaryResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step2">
            <h2>Bước 2: Subnet Mask Là Gì? (Giống Như Ranh Giới Khu Phố)</h2>
            <p>Nếu thành phố quá lớn, ta chia thành các khu phố nhỏ (subnet) để dễ quản lý. Subnet Mask là "ranh giới" nói rằng phần nào là khu phố (network), phần nào là nhà riêng (host).</p>
            <p>Ví dụ: Subnet Mask 255.255.255.0 (hoặc /24) nghĩa là 24 bit đầu là khu phố, 8 bit sau là nhà (có thể có 2^8 = 256 địa chỉ). <strong>Tuy nhiên, chúng ta phải trừ đi 2 địa chỉ: một địa chỉ đầu tiên dùng làm địa chỉ mạng (Network Address) và một địa chỉ cuối cùng dùng làm địa chỉ quảng bá (Broadcast Address).</strong> Vì vậy, thực tế chỉ có 254 nhà dùng được.</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Subnet Mask như biển báo "Khu phố từ số 1 đến 255". Nếu vượt ra, thư sẽ không đến đúng khu.</div>
            <h3>Sơ Đồ Minh Họa: Chia Khu Phố Với Subnet</h3>
            <canvas id="subnetCityCanvas" width="600" height="400"></canvas>
            <div class="interactive">
                <h3>Tương Tác 2: Kéo Slider Để Thay Đổi Kích Thước Khu Phố</h3>
                <p>Kéo thanh trượt để thay đổi /CIDR (số bit cho khu phố). Xem số nhà (host) thay đổi thế nào!</p>
                <label for="cidrSlider">CIDR (/prefix): <span id="cidrValue">24</span></label>
                <input type="range" id="cidrSlider" min="0" max="32" value="24" oninput="updateCidr()" aria-label="CIDR Slider" />
                <div id="bitBar" class="bit-bar"></div>
                <p>Màu xanh dương: Khu phố (Network). Màu xanh lá: Nhà riêng (Host).</p>
                <p>Số nhà khả dụng trong khu: <span id="hostCount">254</span> (luôn trừ 2 cho địa chỉ mạng và quảng bá).</p>
            </div>
        </div>
        <div class="section" id="step3">
            <h2>Bước 3: Tính Toán Subnet (Xem Khu Phố Cụ Thể)</h2>
            <p>Bây giờ, với IP và Subnet, ta tính được: Địa chỉ khu phố đầu (Network), địa chỉ cuối (Broadcast - gửi cho tất cả), và dải nhà dùng được.</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Với địa chỉ "Số 10, Ngõ 1, Phố 168, Quận 192" và ranh giới /24, khu phố là từ số 1 đến 255 ở Ngõ 1, Phố 168, Quận 192.</div>
            <h3>Sơ Đồ Minh Họa: Dải Địa Chỉ Trong Khu Phố</h3>
            <canvas id="addressRangeCanvas" width="600" height="200"></canvas>
            <div class="interactive">
                <h3>Tương Tác 3: Nhập IP Và CIDR Để Tính Toán</h3>
                <input type="text" id="ipInputSubnet" placeholder="IP: 192.168.1.10 hoặc 192.168.1.10/24" aria-label="IP for Subnet Calculation" />
                <input type="text" id="cidrInputSubnet" placeholder="CIDR: /24 (hoặc để trống nếu nhập ở trên)" aria-label="CIDR for Subnet Calculation" />
                <button onclick="calculateSubnet()" aria-label="Calculate Subnet">Tính Và Minh Họa</button>
                <div id="subnetResult" class="result-box"></div>
            </div>
            <div class="interactive">
                <h3>Tương Tác 4: Kiểm Tra IP Có Thuộc Khu Phố Không?</h3>
                <p>Nhập Network (ví dụ 192.168.1.0/24) và một IP để kiểm tra.</p>
                <input type="text" id="networkInput" placeholder="Network: 192.168.1.0/24" aria-label="Network address to check against" />
                <input type="text" id="checkIpInput" placeholder="IP cần kiểm tra: 192.168.1.50" aria-label="IP to check" />
                <button onclick="checkIpInSubnet()" aria-label="Check if IP is in Subnet">Kiểm Tra</button>
                <div id="checkResult" class="result-box"></div>
            </div>
            <div class="case-study">
               <h3>Case Study: Phân chia mạng cho văn phòng</h3>
               <p>Một công ty được cấp dải mạng <strong>192.168.0.0/22</strong>. Họ cần chia ra các mạng con cho các phòng ban:</p>
               <ul>
                   <li><strong>Phòng Kế toán (50 người):</strong> Cần một subnet. Họ có thể dùng <strong>192.168.1.0/26</strong> (cung cấp 62 host).</li>
                   <li><strong>Phòng Kỹ thuật (120 người):</strong> Cần subnet lớn hơn. Họ có thể dùng <strong>192.168.2.0/25</strong> (cung cấp 126 host).</li>
                   <li><strong>Hệ thống Camera IoT (20 thiết bị):</strong> Cần subnet nhỏ. Họ có thể dùng <strong>192.168.3.0/27</strong> (cung cấp 30 host).</li>
               </ul>
               <p>Việc chia subnet giúp tăng cường bảo mật (chỉ các thiết bị trong cùng subnet giao tiếp dễ dàng) và dễ dàng quản lý.</p>
           </div>
        </div>
        <div class="section" id="step4">
            <h2>Bước 4: Quiz Để Kiểm Tra Và Học Thêm</h2>
            <p>Thử quiz này để xem bạn hiểu đến đâu. Có gợi ý nếu sai!</p>
            <div class="interactive">
                <p>Câu 1: IP IPv4 có bao nhiêu bit?</p>
                <select id="quiz1" aria-label="Quiz question 1"><option value="">Chọn...</option><option value="32">32 bit (4 nhóm 8 bit)</option><option value="64">64 bit</option><option value="16">16 bit</option></select>
                <p>Câu 2: Subnet /24 có bao nhiêu bit cho khu phố (network)?</p>
                <select id="quiz2" aria-label="Quiz question 2"><option value="">Chọn...</option><option value="24">24 bit</option><option value="8">8 bit</option><option value="32">32 bit</option></select>
                <p>Câu 3: Với /24, số nhà (host) khả dụng là bao nhiêu?</p>
                <select id="quiz3" aria-label="Quiz question 3"><option value="">Chọn...</option><option value="254">254 (2^8 - 2)</option><option value="256">256</option><option value="128">128</option></select>
                <button onclick="checkQuiz()" aria-label="Check Basic Quiz Answers">Kiểm Tra Đáp Án</button>
                <div id="quizResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step5">
            <h2>Bước 5: Mô Phỏng Mạng Đơn Giản</h2>
            <p>Xem một mạng với router và các máy tính kết nối, mỗi cái có IP trong subnet.</p>
            <canvas id="networkSimulationCanvas" width="800" height="400"></canvas>
        </div>
        <div class="section" id="step6">
            <h2>Bước 6: Subnetting Nâng Cao - Chia Mạng Con</h2>
            <p>Bây giờ, chúng ta học cách chia một mạng lớn thành nhiều mạng con nhỏ hơn. Ví dụ, từ một mạng /24 (256 địa chỉ), chia thành 4 mạng con /26 (mỗi cái 64 địa chỉ).</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Bạn có một khu đất lớn, chia thành 4 khu nhỏ để bán. Mỗi khu nhỏ có ranh giới riêng.</div>
            <h3>Sơ Đồ Minh Họa: Chia Mạng Thành Các Subnet</h3>
            <canvas id="subnettingCanvas" width="600" height="400"></canvas>
            <div class="interactive">
                <h3>Tương Tác 5: Chia Subnet</h3>
                <p>Nhập network gốc và số subnet cần chia.</p>
                <input type="text" id="baseNetwork" placeholder="Network gốc: 192.168.1.0/24" aria-label="Base network for subnetting"/>
                <input type="number" id="numSubnets" placeholder="Số subnet: 4" min="2" max="128" aria-label="Number of subnets to create"/>
                <button onclick="calculateSubnets()" aria-label="Calculate Subnets">Chia Subnet</button>
                <button id="useForVlsmBtn" style="display:none;" onclick="populateVlsm()">Dùng kết quả cho VLSM</button>
                <div id="subnettingResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step7">
            <h2>Bước 7: IP Public Và Private - Internet Thực Tế</h2>
            <p>IP Private (như 192.168.x.x) dùng trong nhà/mạng nội bộ, không ra internet. IP Public là địa chỉ thật trên internet, do ISP cung cấp.</p>
            <p>Các dải IP Private được quy định trong RFC 1918:</p>
            <ul>
                <li><strong>10.0.0.0 /8</strong> (10.0.0.0 đến 10.255.255.255)</li>
                <li><strong>172.16.0.0 /12</strong> (172.16.0.0 đến 172.31.255.255)</li>
                <li><strong>192.168.0.0 /16</strong> (192.168.0.0 đến 192.168.255.255)</li>
            </ul>
            <p><strong>Lưu ý đặc biệt:</strong> Nếu máy tính của bạn nhận được IP trong dải <strong>169.254.0.0/16</strong>, đó là địa chỉ APIPA (Automatic Private IP Addressing). Nó có nghĩa là máy tính không thể kết nối đến máy chủ DHCP để nhận IP.</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> IP Private như số phòng trong nhà bạn. IP Public như địa chỉ nhà ngoài đường lớn.</div>
            <h3>Sơ Đồ Minh Họa: Mạng Nội Bộ Và Internet</h3>
            <canvas id="publicPrivateCanvas" width="600" height="300"></canvas>
            <div class="interactive">
                <h3>Tương Tác 6: Kiểm Tra IP Là Public Hay Private</h3>
                <input type="text" id="ipTypeInput" placeholder="Nhập IP: 192.168.1.1" aria-label="IP to check type" />
                <button onclick="checkIpType()" aria-label="Check IP Type">Kiểm Tra</button>
                <div id="ipTypeResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step8">
            <h2>Bước 8: Quiz Nâng Cao</h2>
            <p>Thử quiz để kiểm tra kiến thức nâng cao!</p>
            <div class="interactive">
                <p>Câu 1: Với /27, số host khả dụng là bao nhiêu?</p>
                <select id="quiz4" aria-label="Advanced quiz question 1"><option value="">Chọn...</option><option value="30">30 (2^5 - 2)</option><option value="32">32</option><option value="62">62</option></select>
                <p>Câu 2: IP 10.0.0.1 là loại gì?</p>
                <select id="quiz5" aria-label="Advanced quiz question 2"><option value="">Chọn...</option><option value="private">Private</option><option value="public">Public</option></select>
                <button onclick="checkAdvancedQuiz()" aria-label="Check Advanced Quiz Answers">Kiểm Tra</button>
                <div id="advancedQuizResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step9">
            <h2>Bước 9: VLSM - Variable Length Subnet Mask (Subnet Linh Hoạt)</h2>
            <p>VLSM cho phép chia subnet với kích thước khác nhau, tiết kiệm địa chỉ IP. Thay vì chia đều, bạn có thể có subnet lớn nhỏ tùy nhu cầu. Nguyên tắc quan trọng là <strong>sắp xếp các yêu cầu về số host từ lớn nhất đến nhỏ nhất</strong> trước khi bắt đầu chia mạng.</p>
            <p>Để tính prefix cho một số lượng host yêu cầu, ta làm theo các bước sau:</p>
            <ol>
                <li>Lấy số host yêu cầu cộng thêm 2 (để dành cho địa chỉ mạng và broadcast).</li>
                <li>Tìm số <code>x</code> nhỏ nhất sao cho <code>2^x</code> lớn hơn hoặc bằng kết quả trên. <code>x</code> chính là số bit cần cho phần host.</li>
                <li>Prefix (CIDR) mới sẽ là <code>32 - x</code>.</li>
            </ol>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Chia khu đất thành các phần: một phần lớn cho công viên, phần nhỏ cho nhà ở, tùy theo nhu cầu.</div>
            <h3>Sơ Đồ Minh Họa: VLSM Với Các Subnet Kích Thước Khác Nhau</h3>
            <canvas id="vlsmCanvas" width="600" height="400"></canvas>
            <div class="interactive">
                <h3>Tương Tác 7: Tính VLSM</h3>
                <p>Nhập network gốc và các kích thước host cần (cách nhau bởi dấu phẩy, ví dụ: 100,50,20). Script sẽ tự động sắp xếp.</p>
                <input type="text" id="vlsmNetwork" placeholder="Network gốc: 192.168.0.0/16" aria-label="Base network for VLSM"/>
                <input type="text" id="vlsmHosts" placeholder="Host cần: 100, 50, 20, 5, 2" aria-label="Required host counts for VLSM"/>
                <button onclick="calculateVLSM()" aria-label="Calculate VLSM">Tính VLSM</button>
                <div id="vlsmResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step10">
            <h2>Bước 10: IPv6 - Thế Hệ IP Mới</h2>
            <p>IPv4 sắp hết địa chỉ, IPv6 dùng 128 bit, dạng hex (ví dụ: 2001:0db8:85a3:0000:0000:8a2e:0370:7334). Nó giải quyết thiếu hụt địa chỉ.</p>
             <h3>Các Loại Địa Chỉ IPv6 Phổ Biến</h3>
            <ul>
                <li><strong>Global Unicast:</strong> Tương tự IP public, có thể định tuyến toàn cầu. Bắt đầu bằng `2000::/3`.</li>
                <li><strong>Link-Local:</strong> Tự động cấu hình trên mọi giao diện, chỉ dùng trong mạng LAN. Bắt đầu bằng `fe80::/10`.</li>
                <li><strong>Unique Local:</strong> Tương tự IP private, dùng trong mạng nội bộ. Bắt đầu bằng `fc00::/7`.</li>
            </ul>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> IPv4 như số điện thoại 10 chữ số sắp hết, IPv6 như số dài hơn để có nhiều hơn.</div>
            <h3>Sơ Đồ Minh Họa: So Sánh IPv4 Và IPv6</h3>
            <canvas id="ipv6Canvas" width="600" height="300"></canvas>
            <div class="interactive">
                <h3>Tương Tác 8: Rút Gọn Địa Chỉ IPv6</h3>
                <p>IPv6 cho phép rút gọn bằng cách bỏ các số 0 đứng đầu trong mỗi khối và thay thế một chuỗi số 0 liên tiếp dài nhất bằng `::`.</p>
                <input type="text" id="ipv6ToCompress" placeholder="VD: 2001:0db8:0000:0000:1234:0000:0000:5678" aria-label="IPv6 to compress"/>
                <button onclick="compressIpv6()" aria-label="Compress IPv6">Rút Gọn</button>
                <div id="ipv6CompressedResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step11">
            <h2>Bước 11: NAT - Network Address Translation</h2>
            <p>NAT cho phép nhiều thiết bị dùng IP private chia sẻ một IP public để ra internet.</p>
            <h3>Các loại NAT</h3>
            <ul>
                <li><strong>SNAT (Source NAT):</strong> Thay đổi địa chỉ IP nguồn của gói tin đi ra ngoài. Đây là loại NAT phổ biến nhất cho mạng gia đình/văn phòng.</li>
                <li><strong>DNAT (Destination NAT) / Port Forwarding:</strong> Thay đổi địa chỉ IP đích của gói tin đi vào. Dùng để public một dịch vụ nội bộ (như web server) ra internet.</li>
                <li><strong>PAT (Port Address Translation):</strong> Một dạng SNAT, map nhiều IP private ra một IP public duy nhất bằng cách sử dụng các port khác nhau. Ví dụ: `192.168.1.10:12345` và `192.168.1.11:54321` đều được map ra `203.0.113.1` nhưng với các port nguồn khác nhau.</li>
            </ul>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Như một người đại diện (router) nhận thư từ bên ngoài và phân phát cho các phòng trong nhà.</div>
            <h3>Sơ Đồ Minh Họa: NAT Trong Mạng Gia Đình</h3>
            <canvas id="natCanvas" width="600" height="400"></canvas>
        </div>
        <div class="section" id="step12">
            <h2>Bước 12: DHCP - Dynamic Host Configuration Protocol (Gán IP Tự Động)</h2>
            <p>DHCP tự động gán IP, subnet mask, gateway cho thiết bị khi kết nối mạng. Quá trình này gọi là <strong>DORA</strong>: Discover, Offer, Request, Acknowledge.</p>
            <p>IP được cấp trong một khoảng thời gian gọi là <strong>Lease Time</strong>. Hết nửa thời gian, client sẽ cố gắng gia hạn (renew). Nếu thất bại, nó sẽ thử lại khi còn 87.5% thời gian (rebinding).</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Như quầy lễ tân khách sạn tự động gán phòng khi bạn check-in, thay vì chọn phòng thủ công.</div>
            <h3>Sơ Đồ Minh Họa: Quá Trình DHCP</h3>
            <canvas id="dhcpCanvas" width="600" height="300"></canvas>
            <div class="interactive">
                <h3>Tương Tác 9: Mô Phỏng Yêu Cầu IP Từ DHCP</h3>
                <p>Nhập "MAC Address" (giả, bất kỳ) và nhấn để xem quá trình cấp phát IP tự động từ pool 192.168.1.0/24.</p>
                <input type="text" id="macInput" placeholder="MAC: 00:11:22:33:44:55" aria-label="Simulated MAC Address"/>
                <label for="leaseTimeSlider">Lease Time (giây): <span id="leaseTimeValue">86400</span></label>
                <input type="range" id="leaseTimeSlider" min="60" max="604800" value="86400" step="60" oninput="document.getElementById('leaseTimeValue').textContent = this.value" aria-label="Lease Time Slider" />
                <button onclick="requestDhcpIp()" aria-label="Request DHCP IP">Yêu Cầu IP</button>
                <div id="dhcpResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step13">
            <h2>Bước 13: DNS - Domain Name System (Chuyển Tên Miền Sang IP)</h2>
            <p>DNS như sổ danh bạ, chuyển tên miền (ví dụ google.com) thành IP để máy tính kết nối. Có nhiều loại bản ghi (record) DNS:</p>
            <ul>
                <li><strong>A Record:</strong> Map tên miền sang địa chỉ IPv4.</li>
                <li><strong>AAAA Record:</strong> Map tên miền sang địa chỉ IPv6.</li>
                <li><strong>CNAME Record (Canonical Name):</strong> Tạo bí danh cho một tên miền khác.</li>
                <li><strong>MX Record (Mail Exchange):</strong> Chỉ định máy chủ email cho tên miền.</li>
                <li><strong>TXT Record:</strong> Chứa thông tin dạng văn bản, thường dùng để xác thực.</li>
            </ul>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Gọi tên bạn bè thay vì số điện thoại, DNS tìm số cho bạn.</div>
            <h3>Sơ Đồ Minh Họa: Quá Trình Resolve DNS</h3>
            <canvas id="dnsCanvas" width="600" height="300"></canvas>
            <div class="interactive">
                <h3>Tương Tác 10: Mô Phỏng Resolve Tên Miền</h3>
                <p>Chọn loại bản ghi, nhập tên miền và xem kết quả (giả).</p>
                <select id="dnsRecordType" aria-label="DNS Record Type">
                    <option value="A">A (IPv4)</option>
                    <option value="AAAA">AAAA (IPv6)</option>
                    <option value="MX">MX (Mail)</option>
                    <option value="CNAME">CNAME (Alias)</option>
                    <option value="TXT">TXT (Text)</option>
                </select>
                <input type="text" id="domainInput" placeholder="Tên miền: example.com" aria-label="Domain name to resolve"/>
                <button onclick="resolveDnsRecord()" aria-label="Resolve Domain">Resolve</button>
                <div id="dnsRecordResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step14">
            <h2>Bước 14: Routing Cơ Bản (Định Tuyến Dữ Liệu)</h2>
            <p>Routing là cách dữ liệu đi từ mạng này sang mạng khác, qua router dựa trên bảng định tuyến.</p>
             <h3>Default Gateway là gì?</h3>
            <p>Default Gateway (cổng mặc định) là một khái niệm cực kỳ quan trọng. Nó chính là địa chỉ IP của Router trong mạng LAN, là cửa ngõ để các thiết bị trong mạng có thể kết nối ra các mạng khác, bao gồm cả Internet. Khi DHCP cấp phát IP, nó cũng sẽ cung cấp địa chỉ Default Gateway này cho các thiết bị.</p>
            <h3>Static vs. Dynamic Routing</h3>
            <ul>
                <li><strong>Static Routing:</strong> Người quản trị phải cấu hình đường đi thủ công. Phù hợp cho mạng nhỏ, đơn giản. Ví dụ lệnh trên router Cisco: `ip route 0.0.0.0 0.0.0.0 192.168.1.1` (gửi mọi traffic không xác định đến gateway 192.168.1.1).</li>
                <li><strong>Dynamic Routing:</strong> Các router tự động chia sẻ thông tin và tìm đường đi tốt nhất bằng các giao thức như OSPF, BGP. Phù hợp cho mạng lớn, phức tạp.</li>
            </ul>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Như bản đồ GPS hướng dẫn đường đi từ nhà bạn đến nhà bạn bè, qua các ngã rẽ (router).</div>
            <h3>Sơ Đồ Minh Họa: Định Tuyến Giữa Các Mạng</h3>
            <canvas id="routingCanvas" width="600" height="400"></canvas>
            <div class="interactive">
                <h3>Tương Tác 11: Kiểm Tra Nếu Cần Router</h3>
                <p>Nhập IP nguồn, IP đích, subnet mask để xem nếu cùng mạng hay cần router.</p>
                <input type="text" id="sourceIp" placeholder="IP nguồn: 192.168.1.10" aria-label="Source IP for routing check"/>
                <input type="text" id="destIp" placeholder="IP đích: 192.168.2.20" aria-label="Destination IP for routing check"/>
                <input type="text" id="maskInput" placeholder="Subnet Mask: 255.255.255.0" aria-label="Subnet Mask for routing check"/>
                <button onclick="checkRouting()" aria-label="Check Routing">Kiểm Tra</button>
                <div id="routingResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step15">
            <h2>Bước 15: Firewall Và Bảo Mật Mạng</h2>
            <p>Firewall như tường lửa, kiểm soát lưu lượng dữ liệu vào/ra mạng, chặn các kết nối nguy hiểm dựa trên quy tắc (IP, port).</p>
            <h3>Stateful vs. Stateless Firewall</h3>
            <ul>
                <li><strong>Stateless:</strong> Kiểm tra từng gói tin một cách độc lập, không nhớ các kết nối trước đó. Nhanh nhưng kém an toàn.</li>
                <li><strong>Stateful:</strong> Theo dõi trạng thái của các kết nối (ví dụ: TCP handshake). Chỉ cho phép các gói tin thuộc một kết nối hợp lệ đi qua. An toàn hơn nhưng tốn tài nguyên hơn.</li>
            </ul>
            <p><strong>Thứ tự luật rất quan trọng:</strong> Firewall xử lý luật từ trên xuống dưới và dừng lại ở luật đầu tiên khớp. Thường có một luật "Default Deny" ở cuối cùng để chặn mọi thứ không được cho phép rõ ràng.</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Như bảo vệ cửa nhà, chỉ cho người quen vào, chặn kẻ lạ.</div>
            <h3>Sơ Đồ Minh Họa Động: Mô Phỏng Firewall Chặn Kết Nối</h3>
            <canvas id="firewallCanvas" width="600" height="400"></canvas>
            <div class="interactive">
                <h3>Tương Tác 12: Thiết Lập Quy Tắc Firewall (JSON)</h3>
                <p>Soạn thảo một mảng các quy tắc bằng JSON. Nhập IP nguồn và port để kiểm tra.</p>
                <textarea id="firewallRules" aria-label="Firewall rules in JSON format">[
{ "action": "allow", "protocol": "tcp", "port": 443, "description": "Allow HTTPS" },
{ "action": "allow", "source_ip": "192.168.1.100", "description": "Allow Admin PC" },
{ "action": "deny", "source_ip": "10.0.0.0/8", "description": "Block internal network" },
{ "action": "deny", "protocol": "any", "description": "Default Deny" }
]</textarea>
                <input type="text" id="firewallCheckIp" placeholder="IP nguồn để kiểm tra: 10.1.2.3" aria-label="Source IP for firewall check" />
                 <input type="number" id="firewallCheckPort" placeholder="Port để kiểm tra: 443" aria-label="Port for firewall check" />
                <button onclick="checkFirewallRules()" aria-label="Check Firewall Rule">Kiểm Tra Với Luật JSON</button>
                <div id="firewallJsonResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step16">
            <h2>Bước 16: VPN - Virtual Private Network (Mạng Riêng Ảo)</h2>
            <p>VPN tạo đường hầm an toàn qua internet, mã hóa dữ liệu, cho phép truy cập mạng từ xa như đang ở văn phòng.</p>
             <h3>Các Loại VPN</h3>
            <ul>
                <li><strong>Remote-Access VPN:</strong> Cho phép người dùng cá nhân kết nối vào mạng công ty.</li>
                <li><strong>Site-to-Site VPN:</strong> Kết nối hai hoặc nhiều mạng văn phòng với nhau qua Internet.</li>
                <li><strong>Giao thức:</strong> IPsec là một bộ giao thức mạnh mẽ, thường dùng cho site-to-site. SSL/TLS VPN thường dễ sử dụng hơn, chạy qua trình duyệt hoặc client, phù hợp cho remote-access.</li>
            </ul>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Như đường hầm bí mật kết nối nhà bạn với công ty, an toàn khỏi kẻ xấu ngoài đường.</div>
            <h3>Sơ Đồ Minh Họa Động: Kết Nối VPN</h3>
            <canvas id="vpnCanvas" width="600" height="300"></canvas>
            <div class="interactive">
                <h3>Tương Tác 13: Mô Phỏng Kết Nối VPN</h3>
                <p>Nhập "Server VPN" và "User IP", nhấn để "kết nối" và xem địa chỉ thay đổi (giả).</p>
                <div style="text-align: center; margin-bottom: 10px;">
                    <label><input type="radio" name="vpnType" value="IPsec" checked> IPsec VPN</label>
                    <label><input type="radio" name="vpnType" value="SSL" style="margin-left: 20px;"> SSL VPN</label>
                </div>
                <input type="text" id="vpnServer" placeholder="Server VPN: vpn.example.com" aria-label="VPN Server Address"/>
                <input type="text" id="userIp" placeholder="User IP: 192.168.1.10" aria-label="User IP for VPN"/>
                <button onclick="connectVpn()" aria-label="Connect VPN">Kết Nối VPN</button>
                <div id="vpnResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step17">
            <h2>Bước 17: Wi-Fi Và Mạng Không Dây</h2>
            <p>Wi-Fi dùng sóng radio để kết nối thiết bị không dây. Bảo mật là yếu tố quan trọng nhất.</p>
             <h3>Các Chuẩn Bảo Mật Wi-Fi</h3>
            <ul>
                <li><strong>WEP (Wired Equivalent Privacy):</strong> Cũ và rất yếu, không nên sử dụng.</li>
                <li><strong>WPA (Wi-Fi Protected Access):</strong> Tốt hơn WEP nhưng vẫn có lỗ hổng.</li>
                <li><strong>WPA2:</strong> Chuẩn phổ biến và an toàn trong nhiều năm, sử dụng mã hóa AES mạnh.</li>
                <li><strong>WPA3:</strong> Thế hệ mới nhất, tăng cường bảo mật, chống lại các cuộc tấn công Brute-force.</li>
            </ul>
            <p>Luôn sử dụng WPA2 hoặc WPA3 với một mật khẩu mạnh (dài, phức tạp, bao gồm chữ hoa, chữ thường, số và ký tự đặc biệt).</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Như radio FM, bạn chọn kênh (SSID) và mật khẩu để nghe riêng.</div>
            <h3>Sơ Đồ Minh Họa Động: Kết Nối Wi-Fi</h3>
            <canvas id="wifiCanvas" width="600" height="400"></canvas>
            <div class="interactive">
                <h3>Tương Tác 14: Mô Phỏng Kết Nối Wi-Fi</h3>
                <p>Nhập SSID và mật khẩu (giả: SSID 'MyWiFi', mật khẩu '12345678'), nhấn để kết nối.</p>
                <input type="text" id="ssidInput" placeholder="SSID: MyWiFi" aria-label="Wi-Fi SSID"/>
                <input type="password" id="wifiPass" placeholder="Mật khẩu" aria-label="Wi-Fi Password" oninput="checkPasswordStrength(this.value)"/>
                <div class="strength-bar"><div id="passwordStrength"></div></div>
                <button onclick="connectWifi()" aria-label="Connect to Wi-Fi">Kết Nối</button>
                <div id="wifiResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step18">
            <h2>Bước 18: Quiz Cuối Cùng</h2>
            <p>Thử quiz để ôn lại toàn bộ kiến thức!</p>
            <div class="interactive">
                <p>Câu 1: Firewall làm gì?</p>
                <select id="quiz6" aria-label="Final quiz question 1"><option value="">Chọn...</option><option value="chặn">Chặn lưu lượng nguy hiểm</option><option value="gán ip">Gán IP tự động</option><option value="resolve">Resolve tên miền</option></select>
                <p>Câu 2: VPN dùng để?</p>
                <select id="quiz7" aria-label="Final quiz question 2"><option value="">Chọn...</option><option value="mã hóa">Mã hóa kết nối an toàn</option><option value="chia subnet">Chia subnet</option><option value="kết nối không dây">Kết nối không dây</option></select>
                <p>Câu 3: Chuẩn bảo mật Wi-Fi nào nên dùng hiện nay?</p>
                <select id="quiz8" aria-label="Final quiz question 3"><option value="">Chọn...</option><option value="wpa23">WPA2 hoặc WPA3</option><option value="wep">WEP</option><option value="wpa">WPA</option></select>
                <button onclick="checkFinalQuiz()" aria-label="Check Final Quiz Answers">Kiểm Tra</button>
                <div id="finalQuizResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step19">
            <h2>Bước 19: Port Và Socket (Cửa Vào Ra Dữ Liệu)</h2>
            <p>Port như số phòng trong tòa nhà (IP là địa chỉ tòa nhà). Socket là kết hợp IP + Port, giúp dữ liệu đến đúng ứng dụng (web port 80, email port 25).</p>
            <h3>Các Dải Port</h3>
            <ul>
                <li><strong>0-1023 (Well-known Ports):</strong> Được dành riêng cho các dịch vụ hệ thống (HTTP: 80, FTP: 21, SSH: 22).</li>
                <li><strong>1024-49151 (Registered Ports):</strong> Dành cho các ứng dụng của người dùng đã đăng ký.</li>
                <li><strong>49152-65535 (Dynamic/Private/Ephemeral Ports):</strong> Được hệ điều hành sử dụng cho các kết nối đi ra ngoài (client-side).</li>
            </ul>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> IP là địa chỉ nhà, port là số phòng, socket là "nhà + phòng" để gửi thư đúng người.</div>
            <h3>Sơ Đồ Minh Họa Động: Dữ Liệu Đi Qua Port</h3>
            <canvas id="portCanvas" width="600" height="300"></canvas>
            <div class="interactive">
                <h3>Tương Tác 15: Kiểm Tra Dịch Vụ Port</h3>
                <p>Nhập số port (0-65535), xem dịch vụ phổ biến.</p>
                <input type="number" id="portInput" placeholder="Port: 80" min="0" max="65535" aria-label="Port number to check"/>
                <button onclick="checkPort()" aria-label="Check Port Service">Kiểm Tra</button>
                <div id="portResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step20">
            <h2>Bước 20: TCP vs UDP - Giao Thức Truyền Dữ Liệu</h2>
            <p>TCP an toàn, đáng tin cậy (như gọi điện xác nhận), UDP nhanh, không xác nhận (như gửi thư thường, dùng cho video/game).</p>
            <p>Ngoài ra còn có các giao thức mới hơn như <strong>QUIC</strong> (dùng bởi HTTP/3), kết hợp tốc độ của UDP và độ tin cậy của TCP; và <strong>SCTP</strong>, dùng cho viễn thông (signaling).</p>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> TCP như chuyển phát nhanh có biên nhận, UDP như phát tờ rơi nhanh nhưng có thể mất.</div>
            <h3>Sơ Đồ Minh Họa Động: So Sánh TCP/UDP</h3>
            <canvas id="tcpUdpCanvas" width="600" height="400"></canvas>
            <div class="interactive">
                <h3>Tương Tác 16: Chọn Giao Thức Cho Ứng Dụng</h3>
                <p>Nhập ứng dụng (web, video, email, game, voice call), xem nên dùng TCP, UDP hay QUIC.</p>
                <input type="text" id="appInput" placeholder="Ứng dụng: video call" aria-label="Application type to suggest protocol"/>
                <button onclick="suggestProtocol()" aria-label="Suggest Protocol">Gợi Ý</button>
                <div id="protocolResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step21">
            <h2>Bước 21: Mô Hình OSI - Các Tầng Mạng</h2>
            <p>OSI có 7 tầng, từ Physical (cáp) đến Application (app). Giúp hiểu dữ liệu đi từ tầng này sang tầng khác.</p>
            <h3>Mapping Giao Thức Lên Các Tầng</h3>
            <ul>
                <li><strong>Layer 7 (Application):</strong> HTTP, FTP, SMTP, DNS</li>
                <li><strong>Layer 4 (Transport):</strong> TCP, UDP, QUIC</li>
                <li><strong>Layer 3 (Network):</strong> IP, ICMP</li>
                <li><strong>Layer 2 (Data Link):</strong> Ethernet, MAC Address, ARP</li>
                <li><strong>Layer 1 (Physical):</strong> Cáp đồng, cáp quang, sóng radio</li>
            </ul>
            <div class="analogy"><strong>Ví Dụ Đời Thường:</strong> Như gửi thư: viết thư (Application), đóng gói (Presentation), địa chỉ (Session), vận chuyển (Transport), đường đi (Network), xe chở (Data Link), đường phố (Physical).</div>
            <h3>Sơ Đồ Minh Họa Động: Các Tầng OSI</h3>
            <canvas id="osiCanvas" width="600" height="500"></canvas>
            <div class="interactive">
                <h3>Tương Tác 17: Khám Phá Tầng OSI</h3>
                <p>Chọn một giao thức, xem nó nằm ở tầng nào.</p>
                <select id="osiProtocolSelect" aria-label="OSI Protocol selector">
                    <option value="">Chọn giao thức...</option>
                    <option value="7">HTTP</option><option value="7">DNS</option>
                    <option value="4">TCP</option><option value="4">UDP</option>
                    <option value="3">IP</option><option value="3">ICMP</option>
                    <option value="2">Ethernet (MAC)</option><option value="2">ARP</option>
                </select>
                <button onclick="highlightOsiLayer()" aria-label="Highlight OSI Layer">Highlight Tầng</button>
                <div id="osiResult" class="result-box"></div>
            </div>
        </div>
        <div class="section" id="step22">
            <h2>Bước 22: Quiz Tổng Hợp</h2>
            <p>Thử quiz để kiểm tra kiến thức từ bước 15-21! Kết quả sẽ được lưu lại để bạn theo dõi tiến độ.</p>
            <div class="interactive">
                <p>Câu 1: Port 80 dùng cho gì?</p>
                <select id="quiz9" aria-label="Comprehensive quiz question 1"><option value="">Chọn...</option><option value="http">HTTP (Web)</option><option value="email">Email</option><option value="ftp">FTP</option></select>
                <p>Câu 2: TCP hay UDP cho video streaming?</p>
                <select id="quiz10" aria-label="Comprehensive quiz question 2"><option value="">Chọn...</option><option value="udp">UDP (Nhanh)</option><option value="tcp">TCP (An toàn)</option></select>
                <p>Câu 3: Tầng 3 OSI là gì?</p>
                <select id="quiz11" aria-label="Comprehensive quiz question 3"><option value="">Chọn...</option><option value="network">Network (IP)</option><option value="physical">Physical</option><option value="application">Application</option></select>
                <button onclick="checkTotalQuiz()" aria-label="Check Comprehensive Quiz Answers">Kiểm Tra</button>
                <div id="totalQuizResult" class="result-box"></div>
                <div id="scoreHistoryChart"></div>
            </div>
        </div>
        
        <div class="section" id="further-reading">
            <h2>Đọc Thêm và Tài Liệu Tham Khảo</h2>
            <p>Kiến thức là vô tận. Nếu bạn muốn tìm hiểu sâu hơn, đây là một số tài liệu tham khảo hữu ích:</p>
            <ul>
                <li><a href="https://en.wikipedia.org/wiki/Subnetwork" target="_blank" rel="noopener noreferrer">Wikipedia: Subnetwork</a> - Giải thích chi tiết về subnetting.</li>
                <li><a href="https://docs.microsoft.com/en-us/windows-server/networking/technologies/dhcp/dhcp-top" target="_blank" rel="noopener noreferrer">Microsoft Docs: DHCP</a> - Tài liệu chính thức về DHCP từ Microsoft.</li>
                <li><a href="https://www.cloudflare.com/learning/dns/dns-records/" target="_blank" rel="noopener noreferrer">Cloudflare: DNS Records</a> - Giải thích các loại bản ghi DNS.</li>
                 <li><a href="https://www.ciscopress.com/topics/networking" target="_blank" rel="noopener noreferrer">Cisco Press Networking</a> - Nguồn tài liệu chuyên sâu từ Cisco.</li>
            </ul>
        </div>
    </div>

    <!-- Modal for Quiz Results -->
    <div id="quizModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalButton" aria-label="Close">&times;</span>
            <div id="modal-body"></div>
        </div>
    </div>
    
<script>
// --- NEW UI/UX AND INTERACTIVITY SCRIPT ---

// --- Core UI Elements ---
const progressBar = document.getElementById('progressBar');
const sidebar = document.getElementById('sidebar');
const sections = document.querySelectorAll('.section');
const sidebarLinks = document.querySelectorAll('.sidebar a');
const themeToggle = document.getElementById('theme-toggle');
const quizModal = document.getElementById('quizModal');
const closeModalButton = document.getElementById('closeModalButton');
const modalBody = document.getElementById('modal-body');
const sidebarToggle = document.getElementById('sidebarToggle');
const sidebarOverlay = document.getElementById('sidebarOverlay');

// --- Progress Bar & Sidebar Active State ---
function updateScrollProgress() {
    const scrollTop = document.documentElement.scrollTop;
    const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    const scrollProgress = (scrollTop / scrollHeight) * 100;
    progressBar.style.width = scrollProgress + '%';

    let currentSection = '';
    sections.forEach(section => {
        const sectionTop = section.offsetTop;
        if (scrollTop >= sectionTop - 100) {
            currentSection = section.getAttribute('id');
        }
    });
    
    sidebarLinks.forEach(link => {
        link.classList.remove('active');
        if(link.getAttribute('href') === `#${currentSection}`) {
            link.classList.add('active');
        }
    });
}

// --- Theme Management ---
function applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    themeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
    localStorage.setItem('theme', theme);
    // Redraw canvases on theme change
    redrawAllCanvases();
}

function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    applyTheme(newTheme);
}

// --- Mobile Sidebar ---
function toggleSidebar() {
    sidebar.classList.toggle('show');
    sidebarOverlay.style.display = sidebar.classList.contains('show') ? 'block' : 'none';
}

// --- Modal ---
function showModal(content) {
    modalBody.innerHTML = content;
    quizModal.style.display = 'flex';
}

function closeModal() {
    quizModal.style.display = 'none';
}

// --- Progress Saving ---
function saveProgress(sectionId) {
    let completedSections = JSON.parse(localStorage.getItem('completedSections')) || [];
    if (!completedSections.includes(sectionId)) {
        completedSections.push(sectionId);
        localStorage.setItem('completedSections', JSON.stringify(completedSections));
        updateProgressUI();
    }
}

function updateProgressUI() {
    let completedSections = JSON.parse(localStorage.getItem('completedSections')) || [];
    completedSections.forEach(sectionId => {
        const sectionEl = document.getElementById(sectionId);
        const navEl = document.getElementById(`nav-${sectionId}`);
        if(sectionEl) sectionEl.classList.add('done');
        if(navEl) navEl.classList.add('done');
    });
}


// --- Event Listeners ---
window.addEventListener('scroll', updateScrollProgress);
themeToggle.addEventListener('click', toggleTheme);
closeModalButton.addEventListener('click', closeModal);
window.addEventListener('click', (event) => {
    if (event.target === quizModal) {
        closeModal();
    }
});
sidebarToggle.addEventListener('click', toggleSidebar);
sidebarOverlay.addEventListener('click', toggleSidebar);
sidebarLinks.forEach(link => {
    link.addEventListener('click', () => {
        if (window.innerWidth <= 992) {
            toggleSidebar();
        }
    });
});
window.addEventListener('resize', redrawAllCanvases);


// --- UTILITY FUNCTIONS ---
function numToIp(num) {
    return [(num >>> 24) & 255, (num >>> 16) & 255, (num >>> 8) & 255, num & 255].join('.');
}
function ipToNum(ip) {
    return ip.split('.').map(Number).reduce((acc, octet) => (acc << 8) | octet, 0) >>> 0;
}
function isIpInCidr(ip, cidrStr) {
    try {
        const [cidrIp, cidrPrefixStr] = cidrStr.split('/');
        const prefix = parseInt(cidrPrefixStr, 10);
        if(isNaN(prefix) || prefix < 0 || prefix > 32) return false;

        const mask = prefix === 0 ? 0 : (~0 << (32 - prefix)) >>> 0;
        const ipNum = ipToNum(ip);
        const cidrIpNum = ipToNum(cidrIp);
        
        return (ipNum & mask) === (cidrIpNum & mask);
    } catch(e) {
        return false;
    }
}
function resizeCanvas(canvas) {
    const { width, height } = canvas.getBoundingClientRect();
    canvas.width = width;
    canvas.height = height || width * 0.5; // fallback height
}
function getThemeColors() {
    const style = getComputedStyle(document.documentElement);
    return {
        bg: style.getPropertyValue('--card-bg'),
        text: style.getPropertyValue('--text-color-light'),
        primary: style.getPropertyValue('--primary-color').trim(),
        success: style.getPropertyValue('--success-color').trim(),
        danger: style.getPropertyValue('--danger-color').trim(),
        warning: style.getPropertyValue('--warning-color').trim(),
        info: style.getPropertyValue('--info-color').trim(),
        secondary: style.getPropertyValue('--secondary-color').trim(),
    };
}


// --- INTERACTIVE FUNCTIONS ---

// Step 1
function convertToBinary() {
    const ip = document.getElementById('ipInputBinary').value.trim();
    const resultDiv = document.getElementById('binaryResult');
    const parts = ip.split('.').map(Number);
    if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
        resultDiv.innerHTML = '<p style="color:red;">IP sai rồi, thử lại nhé! (Ví dụ: 192.168.1.1)</p>';
        return;
    }
    const binary = parts.map(p => p.toString(2).padStart(8, '0')).join(' . ');
    resultDiv.innerHTML = `<p>Nhị Phân: <strong>${binary}</strong></p><p>Đây là cách máy tính đọc IP đấy!</p>`;
    saveProgress('step1');
}

// Step 2
function updateCidr() {
    const cidr = document.getElementById('cidrSlider').value;
    document.getElementById('cidrValue').textContent = cidr;
    const bitBar = document.getElementById('bitBar');
    bitBar.innerHTML = '';
    for (let i = 0; i < 32; i++) {
        const bitDiv = document.createElement('div');
        bitDiv.className = 'bit ' + (i < cidr ? 'network-bit' : 'host-bit');
        bitDiv.title = i < cidr ? 'Network Bit' : 'Host Bit';
        bitDiv.textContent = i < cidr ? 'N' : 'H';
        bitBar.appendChild(bitDiv);
    }
    const hosts = Math.pow(2, 32 - cidr);
    const availableHosts = (hosts > 2) ? hosts - 2 : 0;
    document.getElementById('hostCount').textContent = availableHosts.toLocaleString();
    if(parseInt(cidr) !== 24) saveProgress('step2');
    drawAddressRange(cidr);
}

// Step 3
function calculateSubnet() {
    let ip = document.getElementById('ipInputSubnet').value.trim();
    let cidrStr = document.getElementById('cidrInputSubnet').value.trim();
    const resultDiv = document.getElementById('subnetResult');
    
    if (ip.includes('/')) {
        const parts = ip.split('/');
        ip = parts[0];
        if (!cidrStr) cidrStr = `/${parts[1]}`;
    }

    if (!ip || !cidrStr) {
        resultDiv.innerHTML = '<p style="color:red;">Vui lòng nhập IP và CIDR!</p>';
        return;
    }
    const cidr = parseInt(cidrStr.replace('/', ''));
    if (isNaN(cidr) || cidr < 0 || cidr > 32) {
        resultDiv.innerHTML = '<p style="color:red;">CIDR không hợp lệ! (0-32)</p>';
        return;
    }
    const ipParts = ip.split('.').map(Number);
    if (ipParts.length !== 4 || ipParts.some(p => isNaN(p) || p < 0 || p > 255)) {
        resultDiv.innerHTML = '<p style="color:red;">IP không hợp lệ!</p>';
        return;
    }

    const ipNum = ipToNum(ip);
    const mask = cidr === 0 ? 0 : (~0 << (32 - cidr)) >>> 0;
    const networkNum = ipNum & mask;
    const broadcastNum = networkNum | (~mask >>> 0);
    const numHosts = Math.pow(2, 32 - cidr);
    const availableHosts = numHosts > 2 ? numHosts - 2 : 0;
    
    resultDiv.innerHTML = `
        <p><strong>Địa chỉ mạng (Network Address):</strong> ${numToIp(networkNum)}/${cidr}</p>
        <p><strong>Địa chỉ quảng bá (Broadcast Address):</strong> ${numToIp(broadcastNum)}</p>
        <p><strong>Host đầu tiên:</strong> ${cidr < 31 ? numToIp(networkNum + 1) : 'N/A'}</p>
        <p><strong>Host cuối cùng:</strong> ${cidr < 31 ? numToIp(broadcastNum - 1) : 'N/A'}</p>
        <p><strong>Số Host khả dụng:</strong> ${availableHosts.toLocaleString()}</p>
    `;
    saveProgress('step3');
}

function checkIpInSubnet() {
    const networkStr = document.getElementById('networkInput').value.trim();
    const checkIp = document.getElementById('checkIpInput').value.trim();
    const resultDiv = document.getElementById('checkResult');
    if (!networkStr || !checkIp) {
        resultDiv.innerHTML = '<p style="color:red;">Vui lòng nhập đầy đủ!</p>';
        return;
    }
    if (!networkStr.includes('/')) {
        resultDiv.innerHTML = '<p style="color:red;">Định dạng Network sai (ví dụ: 192.168.1.0/24)</p>';
        return;
    }
    
    const isIn = isIpInCidr(checkIp, networkStr);
    resultDiv.innerHTML = `<p style="color:${isIn ? 'green' : 'red'}; font-weight: bold;">${isIn ? '✔️ Có, IP này thuộc subnet.' : '❌ Không, IP này không thuộc subnet.'}</p>`;
}

// Step 4
function checkQuiz() {
    const ans1 = document.getElementById('quiz1').value;
    const ans2 = document.getElementById('quiz2').value;
    const ans3 = document.getElementById('quiz3').value;
    let score = 0;
    let feedback = '<ul>';
    if (ans1 === '32') { score++; feedback += '<li style="color:green;">Câu 1 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 1 sai: IP IPv4 có 32 bit (4 nhóm 8 bit).</li>'; }
    if (ans2 === '24') { score++; feedback += '<li style="color:green;">Câu 2 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 2 sai: /24 có 24 bit cho network.</li>'; }
    if (ans3 === '254') { score++; feedback += '<li style="color:green;">Câu 3 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 3 sai: Số host là 2^(32-24) - 2 = 254.</li>'; }
    feedback += '</ul>';
    const resultMessage = `<h3>Kết quả: Bạn đúng ${score}/3 câu!</h3> ${feedback}`;
    showModal(resultMessage);
    if (score === 3) saveProgress('step4');
}

// Step 6
function calculateSubnets() {
    const baseStr = document.getElementById('baseNetwork').value.trim();
    const numSubnets = parseInt(document.getElementById('numSubnets').value);
    const resultDiv = document.getElementById('subnettingResult');
    if (!baseStr || isNaN(numSubnets) || numSubnets < 2) {
        resultDiv.innerHTML = '<p style="color:red;">Nhập đúng network và số subnet (lớn hơn 1)!</p>';
        return;
    }
    const [baseIp, baseCidrStr] = baseStr.split('/');
    if (!baseIp || !baseCidrStr) {
        resultDiv.innerHTML = '<p style="color:red;">Định dạng Network sai (ví dụ: 192.168.1.0/24)</p>';
        return;
    }

    const baseCidr = parseInt(baseCidrStr);
    const baseNum = ipToNum(baseIp);
    const bitsNeeded = Math.ceil(Math.log2(numSubnets));
    const newCidr = baseCidr + bitsNeeded;
    if (newCidr > 32) {
        resultDiv.innerHTML = '<p style="color:red;">Không đủ bit để chia!</p>';
        return;
    }
    const subnetSize = Math.pow(2, 32 - newCidr);
    let output = '<p>Các Subnet:</p><ul>';
    for (let i = 0; i < numSubnets; i++) {
        const subnetNum = baseNum + i * subnetSize;
        const network = numToIp(subnetNum);
        const broadcast = numToIp(subnetNum + subnetSize - 1);
        output += `<li><strong>Subnet ${i+1}:</strong> ${network}/${newCidr} (Broadcast: ${broadcast})</li>`;
    }
    output += '</ul>';
    resultDiv.innerHTML = output;
    document.getElementById('useForVlsmBtn').style.display = 'inline-block';
    saveProgress('step6');
}

function populateVlsm() {
    const baseNetwork = document.getElementById('baseNetwork').value;
    const vlsmNetworkInput = document.getElementById('vlsmNetwork');
    vlsmNetworkInput.value = baseNetwork;
    vlsmNetworkInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    document.getElementById('vlsmHosts').focus();
}

// Step 7
function checkIpType() {
    const ip = document.getElementById('ipTypeInput').value.trim();
    const resultDiv = document.getElementById('ipTypeResult');
    const parts = ip.split('.').map(Number);
    if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
        resultDiv.innerHTML = '<p style="color:red;">IP không hợp lệ!</p>';
        return;
    }
    let type = 'Public';
    if ((parts[0] === 10) || (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) || (parts[0] === 192 && parts[1] === 168)) {
        type = 'Private (RFC 1918)';
    } else if (parts[0] === 169 && parts[1] === 254) {
        type = 'APIPA/Link-Local';
    } else if (parts[0] === 127) {
        type = 'Loopback';
    }
    resultDiv.innerHTML = `<p style="font-weight: bold;">Đây là IP <strong>${type}</strong></p>`;
    saveProgress('step7');
}

// Step 8
function checkAdvancedQuiz() {
    const ans4 = document.getElementById('quiz4').value;
    const ans5 = document.getElementById('quiz5').value;
    let score = 0;
    let feedback = '<ul>';
    if (ans4 === '30') { score++; feedback += '<li style="color:green;">Câu 1 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 1 sai: Với /27, có 32-27=5 bit host. Số host là 2^5 - 2 = 30.</li>'; }
    if (ans5 === 'private') { score++; feedback += '<li style="color:green;">Câu 2 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 2 sai: IP 10.x.x.x là IP Private.</li>'; }
    feedback += '</ul>';
    const resultMessage = `<h3>Kết quả: Bạn đúng ${score}/2 câu!</h3> ${feedback}`;
    showModal(resultMessage);
    if (score === 2) saveProgress('step8');
}

// Step 9
function calculateVLSM() {
    const baseStr = document.getElementById('vlsmNetwork').value.trim();
    const hostsStr = document.getElementById('vlsmHosts').value.trim();
    const resultDiv = document.getElementById('vlsmResult');
    if (!baseStr || !hostsStr) {
        resultDiv.innerHTML = '<p style="color:red;">Nhập đầy đủ!</p>';
        return;
    }
    const [baseIp, baseCidrStr] = baseStr.split('/');
    if(!baseIp || !baseCidrStr) {
        resultDiv.innerHTML = '<p style="color:red;">Network gốc không hợp lệ!</p>';
        return;
    }
    const baseCidr = parseInt(baseCidrStr);
    if (isNaN(baseCidr)) {
        resultDiv.innerHTML = '<p style="color:red;">Network gốc không hợp lệ!</p>';
        return;
    }
    const baseNum = ipToNum(baseIp);
    let hosts = hostsStr.split(',').map(Number).filter(n => n > 0).sort((a,b) => b - a);
    if(hosts.some(isNaN)) {
         resultDiv.innerHTML = '<p style="color:red;">Số host không hợp lệ!</p>';
        return;
    }
    let currentNum = baseNum;
    let output = '<p>Các Subnet đã chia (sắp xếp từ lớn đến nhỏ):</p><ul>';
    let error = false;
    hosts.forEach(hostReq => {
        if(error) return;
        const bitsNeeded = Math.ceil(Math.log2(hostReq + 2));
        const newCidr = 32 - bitsNeeded;
        if(newCidr < baseCidr) {
            output += `<li style="color:red;">Lỗi: Yêu cầu ${hostReq} host quá lớn cho mạng gốc!</li>`;
            error = true;
            return;
        }
        const subnetSize = Math.pow(2, bitsNeeded);
        const network = numToIp(currentNum);
        const broadcast = numToIp(currentNum + subnetSize - 1);
        output += `<li>Cho <strong>${hostReq} hosts</strong>: Cần ${hostReq+2} IPs -> Dùng /${newCidr}.<br><strong>Network: ${network}/${newCidr}</strong> (Broadcast: ${broadcast})</li>`;
        currentNum += subnetSize;
    });
    output += '</ul>';
    resultDiv.innerHTML = output;
    saveProgress('step9');
}

// Step 10
function compressIpv6() {
    let ip = document.getElementById('ipv6ToCompress').value.trim();
    const resultDiv = document.getElementById('ipv6CompressedResult');
    if (!ip) {
        resultDiv.innerHTML = '<p style="color:red;">Vui lòng nhập địa chỉ IPv6.</p>';
        return;
    }
    let compressed = ip.replace(/(^|:)0+([0-9a-fA-F])/g, '$1$2'); // remove leading zeros
    compressed = compressed.replace(/((^|:)0){2,}/g, (match, p1) => {
        return p1 === ':' ? '::' : ':';
    });
    // A bit of a simplified compression, but good for demo
    // Proper one is much more complex
    let parts = ip.split(':');
    if (parts.length !== 8) {
         resultDiv.innerHTML = `<p style="color:red">Địa chỉ IPv6 không hợp lệ.</p>`;
         return;
    }
    // Step 1: remove leading zeros in each block
    let cleaned = parts.map(part => part.replace(/^0+/, '') || '0').join(':');

    // Step 2: find the longest sequence of zeros and replace with '::'
    let longest_sequence_start = -1, longest_sequence_length = 0;
    let current_sequence_start = -1, current_sequence_length = 0;
    let cleanedParts = cleaned.split(':');
    for (let i = 0; i < cleanedParts.length; i++) {
        if (cleanedParts[i] === '0') {
            if (current_sequence_start === -1) current_sequence_start = i;
            current_sequence_length++;
        } else {
            if (current_sequence_length > longest_sequence_length) {
                longest_sequence_start = current_sequence_start;
                longest_sequence_length = current_sequence_length;
            }
            current_sequence_start = -1;
            current_sequence_length = 0;
        }
    }
    if (current_sequence_length > longest_sequence_length) {
        longest_sequence_start = current_sequence_start;
        longest_sequence_length = current_sequence_length;
    }

    if (longest_sequence_length > 1) {
        cleanedParts.splice(longest_sequence_start, longest_sequence_length, '');
        cleaned = cleanedParts.join(':').replace(':::', '::');
    }

    resultDiv.innerHTML = `<p>Địa chỉ rút gọn: <strong>${cleaned}</strong></p>`;
    saveProgress('step10');
}

// Step 12
async function requestDhcpIp() {
    const mac = document.getElementById('macInput').value.trim() || '00:11:22:33:44:55';
    const leaseTime = document.getElementById('leaseTimeSlider').value;
    const resultDiv = document.getElementById('dhcpResult');
    resultDiv.innerHTML = '';
    
    const sleep = ms => new Promise(res => setTimeout(res, ms));

    resultDiv.innerHTML += '<p>Client: Gửi DHCP Discover (Broadcast)...</p>';
    await sleep(1000);

    const offeredIp = '192.168.1.' + Math.floor(Math.random() * 253 + 2);
    resultDiv.innerHTML += `<p style="text-align:right;">Server: Nhận Discover, gửi DHCP Offer (IP: ${offeredIp})...</p>`;
    await sleep(1000);
    
    resultDiv.innerHTML += `<p>Client: Nhận Offer, gửi DHCP Request (chấp nhận IP ${offeredIp})...</p>`;
    await sleep(1000);

    resultDiv.innerHTML += `<p style="text-align:right;">Server: Nhận Request, gửi DHCP Acknowledge. Cấp phát thành công!</p>`;
    await sleep(500);

    resultDiv.innerHTML += `<hr><p style="color:var(--success-color); font-weight:bold;">MAC ${mac} đã nhận IP: ${offeredIp}. Thời gian thuê: ${leaseTime} giây.</p>`;
    saveProgress('step12');
}

// Step 13
function resolveDnsRecord() {
    const domain = document.getElementById('domainInput').value.trim() || 'example.com';
    const type = document.getElementById('dnsRecordType').value;
    const resultDiv = document.getElementById('dnsRecordResult');
    let result = '';
    switch(type) {
        case 'A': result = Math.floor(Math.random() * 256) + '.' + Math.floor(Math.random() * 256) + '.' + Math.floor(Math.random() * 256) + '.' + Math.floor(Math.random() * 254 + 1); break;
        case 'AAAA': result = '2001:db8::' + Math.floor(Math.random() * 65535).toString(16); break;
        case 'MX': result = '10 mail.example.com'; break;
        case 'CNAME': result = 'real.server.com'; break;
        case 'TXT': result = '"v=spf1 include:_spf.google.com ~all"'; break;
    }
    resultDiv.innerHTML = `<p><strong>[${type}] ${domain}</strong> -> <strong>${result}</strong></p>`;
    saveProgress('step13');
}

// Step 14
function checkRouting() {
    const source = document.getElementById('sourceIp').value.trim();
    const dest = document.getElementById('destIp').value.trim();
    const maskStr = document.getElementById('maskInput').value.trim();
    const resultDiv = document.getElementById('routingResult');
    if (!source || !dest || !maskStr) {
        resultDiv.innerHTML = '<p style="color:red;">Nhập đầy đủ!</p>';
        return;
    }
    try {
        const sourceNum = ipToNum(source);
        const destNum = ipToNum(dest);
        const maskNum = ipToNum(maskStr);
        const sameNetwork = (sourceNum & maskNum) === (destNum & maskNum);
        resultDiv.innerHTML = `<p style="font-weight:bold;">${sameNetwork ? 'Cùng mạng, không cần router.' : 'Khác mạng, cần router.'}</p>`;
        saveProgress('step14');
    } catch {
        resultDiv.innerHTML = '<p style="color:red;">Format IP hoặc Mask sai!</p>';
    }
}

// Step 15
function checkFirewallRules() {
    const resultDiv = document.getElementById('firewallJsonResult');
    try {
        const rules = JSON.parse(document.getElementById('firewallRules').value);
        const ipStr = document.getElementById('firewallCheckIp').value;
        const port = parseInt(document.getElementById('firewallCheckPort').value);
        
        for (const rule of rules) {
            let ipMatch = !rule.source_ip;
            let portMatch = !rule.port || isNaN(port) || rule.port === port;
            
            if (rule.source_ip) {
                if (rule.source_ip.includes('/')) {
                    ipMatch = isIpInCidr(ipStr, rule.source_ip);
                } else {
                    ipMatch = (ipStr === rule.source_ip);
                }
            }

            if (ipMatch && portMatch) {
                const color = rule.action === 'allow' ? 'var(--success-color)' : 'var(--danger-color)';
                resultDiv.innerHTML = `<p style="color:${color}; font-weight:bold;">Hành động: ${rule.action.toUpperCase()}. Lý do: ${rule.description}</p>`;
                saveProgress('step15');
                return;
            }
        }
         resultDiv.innerHTML = `<p>Không có luật nào khớp.</p>`;
    } catch(e) {
        resultDiv.innerHTML = `<p style="color:red;">Lỗi JSON không hợp lệ!</p>`;
    }
}

// Step 16
function connectVpn() {
    const server = document.getElementById('vpnServer').value.trim() || 'vpn.example.com';
    const ip = document.getElementById('userIp').value.trim() || '192.168.1.10';
    const vpnType = document.querySelector('input[name="vpnType"]:checked').value;
    document.getElementById('vpnResult').innerHTML = `<p>Kết nối đến <strong>${server}</strong> từ <strong>${ip}</strong> qua <strong>${vpnType} VPN</strong> thành công!</p>`;
    saveProgress('step16');
}

// Step 17
function checkPasswordStrength(password) {
    const strengthDiv = document.getElementById('passwordStrength');
    let score = 0;
    if (password.length >= 8) score++;
    if (/[A-Z]/.test(password)) score++;
    if (/[a-z]/.test(password)) score++;
    if (/[0-9]/.test(password)) score++;
    if (/[^A-Za-z0-9]/.test(password)) score++;
    
    let width = (score / 5) * 100;
    const colors = getThemeColors();
    let color = colors.danger; // Yếu
    if (score >= 3) color = colors.warning; // Trung bình
    if (score >= 4) color = colors.success; // Mạnh
    
    strengthDiv.style.width = width + '%';
    strengthDiv.style.backgroundColor = color;
}
function connectWifi() {
    const ssid = document.getElementById('ssidInput').value.trim() || 'MyWiFi';
    const pass = document.getElementById('wifiPass').value.trim();
    if(pass){
        document.getElementById('wifiResult').innerHTML = `<p>Đang thử kết nối đến SSID <strong>${ssid}</strong>...</p>`;
        saveProgress('step17');
    } else {
         document.getElementById('wifiResult').innerHTML = `<p style="color:var(--danger-color)">Vui lòng nhập mật khẩu cho SSID <strong>${ssid}</strong>!</p>`;
    }
}

// Step 18
function checkFinalQuiz() {
    const ans6 = document.getElementById('quiz6').value;
    const ans7 = document.getElementById('quiz7').value;
    const ans8 = document.getElementById('quiz8').value;
    let score = 0;
    let feedback = '<ul>';
    if (ans6 === 'chặn') { score++; feedback += '<li style="color:green;">Câu 1 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 1 sai: Firewall lọc và chặn lưu lượng nguy hiểm.</li>'; }
    if (ans7 === 'mã hóa') { score++; feedback += '<li style="color:green;">Câu 2 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 2 sai: VPN tạo kết nối mã hóa an toàn qua internet.</li>'; }
    if (ans8 === 'wpa23') { score++; feedback += '<li style="color:green;">Câu 3 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 3 sai: Nên dùng WPA2 hoặc WPA3 để bảo mật Wi-Fi.</li>'; }
    feedback += '</ul>';
    const resultMessage = `<h3>Kết quả: Bạn đúng ${score}/3 câu!</h3> ${feedback}`;
    showModal(resultMessage);
    if (score === 3) saveProgress('step18');
}

// Step 19
function checkPort() {
    const port = parseInt(document.getElementById('portInput').value);
    const resultDiv = document.getElementById('portResult');
    let service = 'Unknown';
    let range = '';

    if(port >= 0 && port <= 1023) range = 'Well-known Port';
    else if(port >= 1024 && port <= 49151) range = 'Registered Port';
    else if(port >= 49152 && port <= 65535) range = 'Dynamic/Private Port';
    else {
        resultDiv.innerHTML = `<p style="color:red">Port không hợp lệ</p>`;
        return;
    }

    if (port === 80) service = 'HTTP (Web)';
    else if (port === 443) service = 'HTTPS (Secure Web)';
    else if (port === 21) service = 'FTP (File Transfer)';
    else if (port === 22) service = 'SSH (Secure Shell)';
    else if (port === 25) service = 'SMTP (Email)';
    else if (port === 53) service = 'DNS (Domain Name System)';
    resultDiv.innerHTML = `<p>Port <strong>${port}</strong> thuộc dải <strong>${range}</strong>. Dịch vụ phổ biến: ${service}</p>`;
    saveProgress('step19');
}

// Step 20
function suggestProtocol() {
    const app = document.getElementById('appInput').value.trim().toLowerCase();
    let protocol = 'TCP';
    let reason = 'cần độ tin cậy cao (web, email, file transfer).';
    if (app.includes('video') || app.includes('game') || app.includes('stream') || app.includes('voice')) {
        protocol = 'UDP';
        reason = 'ưu tiên tốc độ hơn độ tin cậy.';
    }
    if (app.includes('video') || app.includes('voice')) {
         protocol = 'UDP hoặc QUIC';
         reason = 'ưu tiên độ trễ thấp. QUIC là một lựa chọn hiện đại.';
    }
    document.getElementById('protocolResult').innerHTML = `<p>Ứng dụng <strong>${app}</strong> nên dùng <strong>${protocol}</strong> vì nó ${reason}</p>`;
    saveProgress('step20');
}

// Step 21
function highlightOsiLayer() {
    const select = document.getElementById('osiProtocolSelect');
    const layer = select.value;
    const protocolName = select.options[select.selectedIndex].text;
    if(!layer) {
        drawOsi(-1);
        return;
    }
    drawOsi(parseInt(layer));
    document.getElementById('osiResult').innerHTML = `<p>Giao thức <strong>${protocolName}</strong> hoạt động ở <strong>Tầng ${layer}</strong>.</p>`;
    saveProgress('step21');
}

// Step 22
function renderScoreChart(quizId) {
    const history = JSON.parse(localStorage.getItem(quizId) || '[]');
    const chartDiv = document.getElementById('scoreHistoryChart');
    if (!history.length || !chartDiv) return;

    const maxScore = 3; 
    const barWidth = 100 / history.length;
    let svgContent = `<svg viewBox="0 0 100 ${maxScore}" preserveAspectRatio="none">`;
    history.forEach((score, index) => {
        const height = score.score;
        const x = index * barWidth;
        svgContent += `<rect class="bar" x="${x}%" y="${maxScore - height}" width="${barWidth - 2}%" height="${height}"><title>Điểm: ${score.score}/${maxScore} - Ngày: ${new Date(score.date).toLocaleString()}</title></rect>`;
    });
    svgContent += '</svg>';
    chartDiv.innerHTML = `<h4>Lịch sử Quiz:</h4>${svgContent}`;
}

function checkTotalQuiz() {
    const ans9 = document.getElementById('quiz9').value;
    const ans10 = document.getElementById('quiz10').value;
    const ans11 = document.getElementById('quiz11').value;
    let score = 0;
    let feedback = '<ul>';
    if (ans9 === 'http') { score++; feedback += '<li style="color:green;">Câu 1 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 1 sai: Port 80 là cổng mặc định cho HTTP (Web).</li>'; }
    if (ans10 === 'udp') { score++; feedback += '<li style="color:green;">Câu 2 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 2 sai: Video streaming ưu tiên tốc độ nên dùng UDP.</li>'; }
    if (ans11 === 'network') { score++; feedback += '<li style="color:green;">Câu 3 đúng!</li>'; } else { feedback += '<li style="color:red;">Câu 3 sai: Tầng 3 (Network) xử lý địa chỉ IP và định tuyến.</li>'; }
    feedback += '</ul>';
    
    // Save score
    const quizId = 'totalQuizHistory';
    const history = JSON.parse(localStorage.getItem(quizId) || '[]');
    history.push({ score: score, date: new Date() });
    if(history.length > 10) history.shift(); // keep last 10 scores
    localStorage.setItem(quizId, JSON.stringify(history));

    const resultMessage = `<h3>Kết quả: Bạn đúng ${score}/3 câu!</h3> ${feedback}`;
    showModal(resultMessage);
    if (score === 3) saveProgress('step22');
    renderScoreChart(quizId);
}


// --- CANVAS DRAWING FUNCTIONS (RESPONSIVE) ---
function drawIpHouse() {
    const canvas = document.getElementById('ipHouseCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = colors.warning;
    ctx.fillRect(w * 0.1, h * 0.5, w * 0.8, h * 0.4);
    ctx.fillStyle = colors.text;
    ctx.font = `${Math.min(w*0.04, 20)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('Thành Phố Internet', w / 2, h * 0.65);
    
    ctx.fillStyle = colors.success;
    const houseW = w * 0.2;
    const houseH = h * 0.3;
    const houseX = w / 2 - houseW / 2;
    const houseY = h * 0.2;
    ctx.beginPath();
    ctx.moveTo(houseX, houseY);
    ctx.lineTo(houseX + houseW / 2, h * 0.05);
    ctx.lineTo(houseX + houseW, houseY);
    ctx.closePath();
    ctx.fill();
    ctx.fillRect(houseX, houseY, houseW, houseH);
    ctx.fillStyle = colors.primary;
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    ctx.fillText('IP: 192.168.1.1', w / 2, h * 0.8);
    ctx.fillStyle = colors.text;
    ctx.fillText('Phần đầu: Network', w * 0.25, h * 0.95);
    ctx.fillText('Phần sau: Host', w * 0.75, h * 0.95);
}

function drawSubnetCity() {
    const canvas = document.getElementById('subnetCityCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };

    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.strokeStyle = colors.danger;
    ctx.lineWidth = 3;
    ctx.strokeRect(w * 0.1, h * 0.1, w * 0.8, h * 0.8);
    ctx.fillStyle = colors.text;
    ctx.font = `${Math.min(w*0.04, 20)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('Thành Phố Lớn (Mạng Chính)', w / 2, h * 0.08);

    ctx.strokeStyle = colors.primary;
    ctx.strokeRect(w * 0.2, h * 0.25, w * 0.6, h * 0.5);
    ctx.fillText('Khu Phố Con (Subnet)', w / 2, h * 0.8);

    for (let i = 0; i < 3; i++) {
        ctx.fillStyle = colors.success;
        ctx.fillRect(w * 0.3 + i * w * 0.15, h * 0.4, w * 0.1, w * 0.1);
    }
}

function drawAddressRange(cidr = 24) {
    const canvas = document.getElementById('addressRangeCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };

    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    
    ctx.fillStyle = '#e9ecef';
    ctx.fillRect(w * 0.1, h * 0.4, w * 0.8, h * 0.2);
    ctx.fillStyle = colors.primary;
    ctx.fillRect(w * 0.1, h * 0.4, (cidr / 32) * w * 0.8, h * 0.2);
    ctx.fillStyle = colors.success;
    ctx.fillRect(w * 0.1 + (cidr / 32) * w * 0.8, h * 0.4, ((32 - cidr) / 32) * w * 0.8, h * 0.2);

    ctx.fillStyle = colors.text;
    ctx.font = `${Math.min(w*0.04, 16)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('Dải Địa Chỉ Toàn Bộ (32 bit)', w / 2, h * 0.2);
    ctx.textAlign = 'left';
    ctx.fillText('Network', w * 0.1, h * 0.75);
    ctx.textAlign = 'right';
    ctx.fillText('Host', w * 0.9, h * 0.75);
}

function drawNetworkSimulation() {
    const canvas = document.getElementById('networkSimulationCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };

    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = colors.primary;
    const routerR = Math.min(w * 0.08, 50);
    ctx.beginPath();
    ctx.arc(w / 2, h * 0.2, routerR, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.font = `${Math.min(w*0.03, 20)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('Router', w / 2, h * 0.2 + 5);
    ctx.fillStyle = colors.text;
    ctx.fillText('192.168.1.1/24', w / 2, h * 0.2 + routerR + 20);

    const hosts = [
        { x: w * 0.2, y: h * 0.7, ip: '1.10' }, 
        { x: w * 0.5, y: h * 0.7, ip: '1.20' }, 
        { x: w * 0.8, y: h * 0.7, ip: '1.30' }
    ];
    const hostR = Math.min(w * 0.07, 40);
    hosts.forEach(host => {
        ctx.fillStyle = colors.success;
        ctx.beginPath();
        ctx.arc(host.x, host.y, hostR, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = colors.text;
        ctx.font = `${Math.min(w*0.025, 12)}px Arial`;
        ctx.fillText(`192.168.${host.ip}`, host.x, host.y + hostR + 15);
        ctx.strokeStyle = colors.secondary;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(w / 2, h * 0.2 + routerR);
        ctx.lineTo(host.x, host.y - hostR);
        ctx.stroke();
    });
}

function drawSubnetting() {
    const canvas = document.getElementById('subnettingCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = colors.text;
    ctx.font = `${Math.min(w*0.04, 20)}px Arial`;
    ctx.textAlign = 'center';

    ctx.strokeStyle = colors.danger;
    ctx.lineWidth = 3;
    ctx.strokeRect(w*0.1, h*0.1, w*0.8, h*0.2);
    ctx.fillText('Mạng Gốc /24', w/2, h*0.08);

    for (let i = 0; i < 4; i++) {
        ctx.strokeStyle = colors.primary;
        ctx.strokeRect(w*0.05 + i * w*0.23, h*0.5, w*0.2, h*0.3);
        ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
        ctx.fillText(`Subnet ${i + 1} /26`, w*0.15 + i*w*0.23, h*0.85);
        ctx.strokeStyle = colors.secondary;
        ctx.beginPath();
        ctx.moveTo(w/2, h*0.3);
        ctx.lineTo(w*0.15 + i*w*0.23, h*0.5);
        ctx.stroke();
    }
}

function drawPublicPrivate() {
    const canvas = document.getElementById('publicPrivateCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = colors.success;
    ctx.fillRect(w * 0.1, h * 0.3, w * 0.3, h * 0.4);
    ctx.fillStyle = 'white';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('Private Network', w * 0.25, h / 2);

    ctx.fillStyle = colors.primary;
    ctx.beginPath();
    ctx.arc(w * 0.8, h / 2, w*0.1, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.fillText('Internet', w * 0.8, h / 2);

    ctx.strokeStyle = colors.danger;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(w * 0.4, h / 2);
    ctx.lineTo(w * 0.7, h / 2);
    ctx.stroke();
    ctx.fillStyle = colors.text;
    ctx.fillText('Router (NAT)', w * 0.55, h*0.5 + 20);
}

function drawVlsm() {
    const canvas = document.getElementById('vlsmCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };

    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    ctx.strokeStyle = colors.danger;
    ctx.lineWidth = 3;
    ctx.strokeRect(w*0.1, h*0.1, w*0.8, h*0.15);
    ctx.fillStyle = colors.text;
    ctx.font = `${Math.min(w*0.04, 20)}px Arial`;
    ctx.fillText('Mạng Gốc /16', w/2, h*0.08);

    ctx.textAlign = 'left';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    ctx.strokeStyle = colors.primary;
    ctx.strokeRect(w*0.1, h*0.4, w*0.6, h*0.15);
    ctx.fillText('Subnet for 100 hosts (/25)', w*0.12, h*0.5);
    ctx.strokeStyle = colors.success;
    ctx.strokeRect(w*0.1, h*0.6, w*0.3, h*0.15);
    ctx.fillText('Subnet for 50 hosts (/26)', w*0.12, h*0.7);
    ctx.strokeStyle = colors.warning;
    ctx.strokeRect(w*0.45, h*0.6, w*0.2, h*0.15);
    ctx.fillText('Subnet for 20 hosts (/27)', w*0.47, h*0.7);
}

function drawIpv6() {
    const canvas = document.getElementById('ipv6Canvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.font = `${Math.min(w*0.04, 18)}px Arial`;
    ctx.textAlign = 'center';

    ctx.fillStyle = colors.primary;
    ctx.fillRect(w*0.1, h*0.2, w*0.4, h*0.2);
    ctx.fillStyle = 'white';
    ctx.fillText('IPv4: 32 bit', w*0.3, h*0.3);
    
    ctx.fillStyle = colors.success;
    ctx.fillRect(w*0.1, h*0.6, w*0.8, h*0.2);
    ctx.fillStyle = 'white';
    ctx.fillText('IPv6: 128 bit', w*0.5, h*0.7);
}

function drawNat() {
    const canvas = document.getElementById('natCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    
    const routerR = Math.min(w * 0.08, 50);
    ctx.fillStyle = colors.primary;
    ctx.beginPath();
    ctx.arc(w/2, h*0.3, routerR, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    ctx.fillText('NAT Router', w/2, h*0.3);
    ctx.fillStyle = colors.text;
    ctx.fillText('Public: 203.0.113.1', w/2, h*0.3 + routerR + 20);

    ctx.fillStyle = colors.danger;
    const internetR = Math.min(w * 0.1, 60);
    ctx.beginPath();
    ctx.arc(w*0.85, h*0.3, internetR, 0, 2*Math.PI);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.fillText('Internet', w*0.85, h*0.3);

    ctx.strokeStyle = colors.secondary;
    ctx.beginPath();
    ctx.moveTo(w/2 + routerR, h*0.3);
    ctx.lineTo(w*0.85 - internetR, h*0.3);
    ctx.stroke();

    for (let i = 0; i < 3; i++) {
        const hostX = w*0.2 + i * w*0.3;
        const hostY = h*0.7;
        ctx.fillStyle = colors.success;
        ctx.fillRect(hostX - w*0.07, hostY - h*0.1, w*0.14, h*0.2);
        ctx.fillStyle = colors.text;
        ctx.fillText('192.168.1.' + (10+i), hostX, hostY+h*0.15);
        
        ctx.beginPath();
        ctx.moveTo(hostX, hostY - h*0.1);
        ctx.lineTo(w/2, h*0.3 + routerR);
        ctx.stroke();
    }
}

function drawDhcp() {
    const canvas = document.getElementById('dhcpCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };

    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    
    ctx.fillStyle = colors.success;
    ctx.fillRect(w*0.1, h*0.3, w*0.2, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('Client', w*0.2, h*0.5);

    ctx.fillStyle = colors.primary;
    ctx.fillRect(w*0.7, h*0.3, w*0.2, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('DHCP Server', w*0.8, h*0.5);
    
    ctx.fillStyle = colors.text;
    ctx.fillText('1. Discover ➔', w/2, h*0.3);
    ctx.fillText('🠐 2. Offer', w/2, h*0.45);
    ctx.fillText('3. Request ➔', w/2, h*0.6);
    ctx.fillText('🠐 4. ACK', w/2, h*0.75);
}

function drawDns() {
    const canvas = document.getElementById('dnsCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;

    ctx.fillStyle = colors.success;
    ctx.fillRect(w*0.1, h*0.3, w*0.2, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('Client', w*0.2, h*0.5);
    
    ctx.fillStyle = colors.primary;
    ctx.fillRect(w*0.7, h*0.3, w*0.2, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('DNS Server', w*0.8, h*0.5);

    ctx.fillStyle = colors.text;
    ctx.fillText('Query: "example.com"? ➔', w/2, h*0.4);
    ctx.fillText('🠐 Response: "93.184.216.34"', w/2, h*0.6);
}

function drawRouting() {
    const canvas = document.getElementById('routingCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    
    ctx.strokeStyle = colors.success;
    ctx.strokeRect(w*0.05, h*0.2, w*0.3, h*0.6);
    ctx.fillText('Mạng 1: 192.168.1.0/24', w*0.2, h*0.15);
    
    ctx.fillStyle = colors.primary;
    ctx.beginPath();
    ctx.arc(w/2, h/2, w*0.08, 0, 2*Math.PI);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.fillText('Router', w/2, h/2);
    
    ctx.strokeStyle = colors.danger;
    ctx.strokeRect(w*0.65, h*0.2, w*0.3, h*0.6);
    ctx.fillStyle = colors.text;
    ctx.fillText('Mạng 2: 192.168.2.0/24', w*0.8, h*0.15);
    
    ctx.strokeStyle = colors.secondary;
    ctx.beginPath();
    ctx.moveTo(w*0.35, h/2);
    ctx.lineTo(w/2-w*0.08, h/2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(w/2+w*0.08, h/2);
    ctx.lineTo(w*0.65, h/2);
    ctx.stroke();
}

function drawFirewall(packetX, status) {
    const canvas = document.getElementById('firewallCanvas');
     if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };

    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;

    ctx.fillStyle = colors.success;
    ctx.fillRect(w*0.1, h*0.3, w*0.25, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('Mạng Nội Bộ', w*0.225, h/2);
    
    ctx.fillStyle = colors.danger;
    ctx.fillRect(w/2 - w*0.02, h*0.2, w*0.04, h*0.6);
    
    ctx.fillStyle = colors.primary;
    ctx.beginPath();
    ctx.arc(w*0.8, h/2, w*0.1, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = 'white';
    ctx.fillText('Internet', w*0.8, h/2);
    
    if (packetX) {
        ctx.fillStyle = status === 'blocked' ? colors.danger : colors.success;
        ctx.beginPath();
        ctx.arc(packetX, h/2, w*0.02, 0, 2 * Math.PI);
        ctx.fill();

        if (status) {
            ctx.font = `${Math.min(w*0.04, 20)}px Arial`;
            ctx.fillStyle = status === 'blocked' ? colors.danger : colors.success;
            ctx.fillText(status === 'blocked' ? 'Chặn!' : 'Cho phép!', w*0.6, h*0.3);
        }
    }
}
let firewallAnimationId;
function animateFirewall() {
    cancelAnimationFrame(firewallAnimationId);
    const canvas = document.getElementById('firewallCanvas');
    if (!canvas?.getContext) return;
    let x = canvas.width * 0.7;
    const isBlocked = Math.random() > 0.5;
    const firewallEdge = canvas.width/2 + canvas.width*0.02;
    const allowedDest = canvas.width * 0.3;
    function animate() {
        if ((isBlocked && x <= firewallEdge) || (!isBlocked && x <= allowedDest)) {
            drawFirewall(x, isBlocked ? 'blocked' : 'allowed');
            return;
        }
        drawFirewall(x);
        x -= 5;
        firewallAnimationId = requestAnimationFrame(animate);
    }
    animate();
}

function drawVpn(packetX) {
    const canvas = document.getElementById('vpnCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };

    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    
    ctx.fillStyle = colors.success;
    ctx.fillRect(w*0.1, h*0.3, w*0.2, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('User', w*0.2, h/2);
    
    ctx.fillStyle = colors.primary;
    ctx.fillRect(w*0.7, h*0.3, w*0.2, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('VPN Server', w*0.8, h/2);

    ctx.fillStyle = 'rgba(220, 53, 69, 0.5)';
    ctx.fillRect(w*0.3, h*0.4, w*0.4, h*0.2);
    ctx.fillStyle = colors.text;
    ctx.fillText('Encrypted Tunnel', w/2, h*0.65);
    
    if (packetX) {
        ctx.fillStyle = colors.warning;
        ctx.beginPath();
        ctx.arc(packetX, h/2, w*0.02, 0, 2*Math.PI);
        ctx.fill();
    }
}
let vpnAnimationId;
function animateVpn() {
    cancelAnimationFrame(vpnAnimationId);
    const canvas = document.getElementById('vpnCanvas');
    if (!canvas?.getContext) return;
    let x = canvas.width * 0.3;
    const dest = canvas.width * 0.7;
    function animate() {
        if(x >= dest) {
            drawVpn();
            const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
            ctx.fillStyle = colors.success;
            ctx.font = `${Math.min(w*0.04, 20)}px Arial`;
            ctx.fillText('Connected!', w*0.8, h*0.25);
            return;
        }
        drawVpn(x);
        x += 5;
        vpnAnimationId = requestAnimationFrame(animate);
    }
    animate();
}

function drawWifi(radius) {
    const canvas = document.getElementById('wifiCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    
    const routerR = Math.min(w*0.05, 30);
    ctx.fillStyle = colors.primary;
    ctx.beginPath();
    ctx.arc(w/2, h/2, routerR, 0, 2 * Math.PI);
    ctx.fill();
    
    for (let i = 1; i <= 3; i++) {
        ctx.strokeStyle = colors.primary;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(w/2, h/2, routerR + i * w*0.04, -Math.PI/3, Math.PI/3);
        ctx.stroke();
    }

    if (radius) {
         ctx.strokeStyle = colors.warning;
         ctx.lineWidth = 4;
         ctx.beginPath();
         ctx.arc(w/2, h/2, radius, 0, 2 * Math.PI);
         ctx.stroke();
    }
}
let wifiAnimationId;
function animateWifi() {
    cancelAnimationFrame(wifiAnimationId);
    const canvas = document.getElementById('wifiCanvas');
    if (!canvas?.getContext) return;
    let radius = Math.min(w*0.05, 30);
    const maxRadius = canvas.width * 0.4;
    function animate() {
        if (radius > maxRadius) {
             drawWifi();
             return;
        }
        drawWifi(radius);
        radius += 5;
        wifiAnimationId = requestAnimationFrame(animate);
    }
    animate();
}

function drawPort(packetY) {
    const canvas = document.getElementById('portCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    ctx.textAlign = 'center';
    
    ctx.fillStyle = colors.secondary;
    ctx.fillRect(w*0.3, h*0.25, w*0.4, h*0.6);
    ctx.fillStyle = colors.text;
    ctx.fillText('Server IP', w/2, h*0.2);

    const ports = [{num: 80}, {num: 443}, {num: 21}];
    ports.forEach((port, i) => {
        ctx.fillStyle = colors.primary;
        ctx.fillRect(w*0.35 + i*w*0.1, h*0.5, w*0.08, h*0.1);
        ctx.fillStyle = 'white';
        ctx.fillText('P:' + port.num, w*0.39 + i*w*0.1, h*0.57);
    });
    
    if (packetY) {
        ctx.fillStyle = colors.danger;
        ctx.beginPath();
        ctx.arc(w*0.39, packetY, w*0.02, 0, 2*Math.PI);
        ctx.fill();
    }
}
let portAnimationId;
function animatePort() {
    cancelAnimationFrame(portAnimationId);
    const canvas = document.getElementById('portCanvas');
    if (!canvas?.getContext) return;
    let y = canvas.height * 0.1;
    const dest = canvas.height * 0.5;
    function animate() {
        if(y > dest) {
            drawPort();
            return;
        }
        drawPort(y);
        y += 5;
        portAnimationId = requestAnimationFrame(animate);
    }
    animate();
}

function drawTcpUdp(tcpX, udpX) {
    const canvas = document.getElementById('tcpUdpCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.font = `${Math.min(w*0.03, 16)}px Arial`;
    ctx.textAlign = 'center';

    ctx.fillStyle = colors.primary;
    ctx.fillRect(w*0.1, h*0.2, w*0.3, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('TCP: Tin cậy', w*0.25, h*0.3);
    
    ctx.fillStyle = colors.danger;
    ctx.fillRect(w*0.6, h*0.2, w*0.3, h*0.4);
    ctx.fillStyle = 'white';
    ctx.fillText('UDP: Nhanh', w*0.75, h*0.3);
    
    if (tcpX) {
        ctx.fillStyle = colors.success;
        ctx.beginPath();
        ctx.arc(tcpX, h*0.8, w*0.02, 0, 2*Math.PI);
        ctx.fill();
        if(tcpX > w*0.25){ // ACK
             ctx.fillStyle = colors.warning;
             ctx.beginPath();
             ctx.arc(tcpX-w*0.1, h*0.8, w*0.015, 0, 2*Math.PI);
             ctx.stroke();
        }
    }
    if (udpX) {
        ctx.fillStyle = colors.success;
        ctx.beginPath();
        ctx.arc(udpX, h*0.8, w*0.02, 0, 2*Math.PI);
        ctx.fill();
    }
}
let tcpUdpAnimationId;
function animateTcpUdp() {
    cancelAnimationFrame(tcpUdpAnimationId);
    const canvas = document.getElementById('tcpUdpCanvas');
    if (!canvas?.getContext) return;
    const { w, h } = canvas;
    let tcpX = w*0.25, udpX = w*0.75;
    const dest = w;

    function animate() {
        let tcpDone = tcpX > dest;
        let udpDone = udpX > dest;
        if(tcpDone && udpDone) {
            drawTcpUdp();
            return;
        }
        drawTcpUdp(tcpX, udpX);
        if(!tcpDone) tcpX += 2;
        if(!udpDone) udpX += 5;
        tcpUdpAnimationId = requestAnimationFrame(animate);
    }
    animate();
}

function drawOsi(highlightLayer = -1) {
    const canvas = document.getElementById('osiCanvas');
    if (!canvas?.getContext) return;
    resizeCanvas(canvas);
    const ctx = canvas.getContext('2d');
    const { w, h, colors } = { w: canvas.width, h: canvas.height, colors: getThemeColors() };
    
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, w, h);
    ctx.textAlign = 'center';
    
    const layers = ['7. Application', '6. Presentation', '5. Session', '4. Transport', '3. Network', '2. Data Link', '1. Physical'];
    const layerHeight = h*0.12;
    for (let i = 0; i < 7; i++) {
        if (i === (7-highlightLayer)) {
            ctx.fillStyle = colors.warning;
        } else {
            ctx.fillStyle = `hsl(${i*50}, 70%, 50%)`;
        }
        ctx.fillRect(w*0.1, h*0.05 + i * layerHeight, w*0.8, layerHeight * 0.9);
        ctx.fillStyle = 'white';
        ctx.font = `${Math.min(w*0.03, 18)}px Arial`;
        ctx.fillText(layers[i], w/2, h*0.05 + i * layerHeight + layerHeight*0.5);
    }
}


const animatedCanvases = [
    { id: 'firewallCanvas', func: animateFirewall },
    { id: 'vpnCanvas', func: animateVpn },
    { id: 'wifiCanvas', func: animateWifi },
    { id: 'portCanvas', func: animatePort },
    { id: 'tcpUdpCanvas', func: animateTcpUdp }
];

const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const canvasId = entry.target.id;
            const anim = animatedCanvases.find(c => c.id === canvasId);
            if (anim) {
                anim.func();
                observer.unobserve(entry.target);
            }
        }
    });
}, { threshold: 0.5 });


function redrawAllCanvases() {
    drawIpHouse();
    drawSubnetCity();
    updateCidr();
    drawNetworkSimulation();
    drawSubnetting();
    drawPublicPrivate();
    drawVlsm();
    drawIpv6();
    drawNat();
    drawDhcp();
    drawDns();
    drawRouting();
    drawFirewall();
    drawVpn();
    drawWifi();
    drawPort();
    drawTcpUdp();
    drawOsi();
}

// Initial setup on page load
window.onload = () => {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.setAttribute('data-theme', savedTheme);
    themeToggle.textContent = savedTheme === 'dark' ? '☀️' : '🌙';

    updateProgressUI();
    
    redrawAllCanvases();

    renderScoreChart('totalQuizHistory');

    updateScrollProgress();

    animatedCanvases.forEach(item => {
        const el = document.getElementById(item.id);
        if(el) observer.observe(el);
    });
};
</script>
</body>
</html>
